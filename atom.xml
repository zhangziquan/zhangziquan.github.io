<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Legend never dies</title>
  
  <subtitle>zhangzq index</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ziquanzhang.ink/"/>
  <updated>2018-11-17T08:48:44.730Z</updated>
  <id>http://ziquanzhang.ink/</id>
  
  <author>
    <name>zhang ziquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[LeetCode] 354. Russian Doll Envelopes</title>
    <link href="http://ziquanzhang.ink/2018/11/17/LeetCode-354-Russian-Doll-Envelopes/"/>
    <id>http://ziquanzhang.ink/2018/11/17/LeetCode-354-Russian-Doll-Envelopes/</id>
    <published>2018-11-17T08:45:00.000Z</published>
    <updated>2018-11-17T08:48:44.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="354-russian-doll-envelopes"><a class="markdownIt-Anchor" href="#354-russian-doll-envelopes"></a> 354. Russian Doll Envelopes</h1><p>week11</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>You have a number of envelopes with widths and heights given as a pair of integers <code>(w, h)</code>. One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p><p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p><p><strong>Note:</strong></p><p>Rotation is not allowed.</p><p><strong>Example:</strong></p><pre><code>Input: [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</code></pre><hr><h2 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h2><p>  再来一道动态规划的题目，本题是一道变形的最长子串题目，讲的是俄罗斯套娃那种排序，N个信封给出高和宽，若一个信封的高和宽都大于另一个信封，则可以装进去，目标求最长的序列。</p><hr><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2><p>  这是一道比较常见的动态规划问题，记录每一个信封的最大装载数量，若有信封能装进该信封，那么比较装载数量，然后逐步找到最大装载数量的信封即可。</p><p>  将信封从小到大排序，宽度从小到大，宽度相同则高度从小到大，对后面的信封都要遍历前面的信封，看是否能装进去，然后更新dp，每次都比较下信封的最大装载量。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;envelopes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(envelopes.size(), <span class="number">1</span>);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp;</span><br><span class="line">        sort(envelopes.begin(), envelopes.end());</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i].first &gt; envelopes[j].first &amp;&amp;</span><br><span class="line">                    envelopes[i].second &gt; envelopes[j].second)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum = max(maxnum, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果反思"><a class="markdownIt-Anchor" href="#结果反思"></a> 结果反思</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Russian%20Doll%20Envelopes_test.png?x-oss-process=style/Blog-Normal" alt="测试" title="">                </div>                <div class="image-caption">测试</div>            </figure><p>  从结果看来这种做法算是中规中矩，就是不断地去遍历，对信封的装载数量进行不断更新，最后达到收敛，就像Bellman-Ford算法一样不断更新，而且这个好像更加慢。。</p><hr><h3 id="目前最佳解法"><a class="markdownIt-Anchor" href="#目前最佳解法"></a> 目前最佳解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.first &lt; p2.first) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p1.first == p2.first) &#123; <span class="keyword">return</span> p1.second &gt; p2.second; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p : envelopes) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(dp.begin(), dp.end(), p, cmp2);</span><br><span class="line">            <span class="keyword">if</span> (iter == dp.end()) &#123;</span><br><span class="line">                dp.push_back(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[iter - dp.begin()] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h3><p>  第二种解法，这个似乎是现在最多且很快的解法，和求最长递增子串的长度相类似，运用了其中的思想，也就是贪心和二分的想法，先对宽度从小到大进行排序，这样能保证后面的信封能装进前面的信封，然后对高度进行最长递增子串寻找最长，这样就能得到最长，也许会出现宽度相同的情况，但是这也说明了最长递增子串这个问题的想法，得到的解并不会是正确的解，但是长度是相同的，对较大的进行置换成小的使得它能够得到更大的潜力去递增，这就是贪心的策略，在贪心的同时并没有改变其中的长度，很精妙。。。</p><hr><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>  这个题目说明了动态规划有时候并不会是最简单的，但也是比较快的了，动态规划能够避免许多小问题的重复求解，在求得对应的序列比递归有很大的优势，在一些问题归纳若子问题的规模仍很大，那么动态规划比递归好很多。第二种的贪心二分算法是在题目只要求得长度，这样贪心算法就能最速得到长度，但是始终得不到序列。要得到指定序列还是需要动态规划。可以说是套着dp的皮，实则是贪心策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;354-russian-doll-envelopes&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#354-russian-doll-envelopes&quot;&gt;&lt;/a&gt; 354. Russian Doll Envelopes&lt;/h1&gt;
&lt;p
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://ziquanzhang.ink/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="http://ziquanzhang.ink/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 514. Freedom Trail</title>
    <link href="http://ziquanzhang.ink/2018/11/09/eetCode-514-Freedom-Trail/"/>
    <id>http://ziquanzhang.ink/2018/11/09/eetCode-514-Freedom-Trail/</id>
    <published>2018-11-09T08:52:00.000Z</published>
    <updated>2018-11-09T09:12:44.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="514-Freedom-Trail"><a href="#514-Freedom-Trail" class="headerlink" title="514. Freedom Trail"></a>514. Freedom Trail</h1><p>week10</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/freedom-trail/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>In the video game Fallout 4, the quest “Road to Freedom” requires players to reach a metal dial called the “Freedom Trail Ring”, and use the dial to spell a specific keyword in order to open the door.</p><p>Given a string <strong>ring</strong>, which represents the code engraved on the outer ring and another string <strong>key</strong>, which represents the keyword needs to be spelled. You need to find the <strong>minimum</strong> number of steps in order to spell all the characters in the keyword.</p><p>Initially, the first character of the <strong>ring</strong> is aligned at 12:00 direction. You need to spell all the characters in the string <strong>key</strong> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <strong>key</strong> aligned at 12:00 direction and then by pressing the center button.</p><p>At the stage of rotating the ring to spell the key character <strong>key[i]</strong>:</p><ol><li><p>You can rotate the <strong>ring</strong> clockwise or anticlockwise <strong>one place</strong>, which counts as 1 step. The final purpose of the rotation is to align one of the string <strong>ring’s</strong> characters at the 12:00 direction, where this character must equal to the character <strong>key[i]</strong>.</p></li><li><p>If the character <strong>key[i]</strong> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you’ve finished all the spelling.</p></li></ol><p><strong>Example:</strong></p><div align="center"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Freedom%20Trail_example.jpg?x-oss-process=style/Reprint" alt="example" title="">                </div>                <div class="image-caption">example</div>            </figure></div><p><strong>Input:</strong> ring = “godding”, key = “gd”<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>For the first key character ‘g’, since it is already in place, we just need 1 step to spell this character.<br>For the second key character ‘d’, we need to rotate the ring “godding” anticlockwise by two steps to make it become “ddinggo”.<br>Also, we need 1 more step for spelling.<br>So the final output is 4.</p><p><strong>Note:</strong></p><ol><li>Length of both ring and <strong>key</strong> will be in range 1 to 100.</li><li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li><li>It’s guaranteed that string <strong>key</strong> could always be spelled by rotating the string <strong>ring</strong>.</li></ol><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;题目看起来很复杂，其实很简单，说的是辐射4中的一个小游戏，即通过旋转按钮将指针指向对应的字符串，从而根据key按顺序来按出所有的字母，这个按钮可以顺时针或者逆时针旋转，要求算出拼出key的最少步数（按下按钮也算一步）。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;因为旋钮可以左旋或者右旋，所以每一次的旋转过后的指针都有可能不一样，因为旋钮上的字母是可重复的。可以说每一次的最短路径都不一样。因此我们不能简单的认为每一次都取最短路径就行了，因为上一次的选择会影响下一次的进行。</p><p>&emsp;&emsp;这样看来这道题目明显就是动态规划中的最短路径问题，我们可以计算一下每个状态下的步数，到达下一个状态取上一个状态+到达下一个状态的步数的最小值，类似于最短路径的做法。因为知道一开始指针必定是指向12点钟方向，所以可以从后往前推，f(i,j) = min(f(i,j),abs(j-k) + f(i+1,k)),求得的f(0)即是最小的步数。定义一个二维数组或者二维向量即可保存其状态，其中i为当前已匹配数，j为指针的方向（指向的位置）。</p><p>&emsp;&emsp;因为每一次都要按一下确认，所以直接在最后加上key的长度。因为key和ring长度不定，建议使用二维向量。</p><h3 id="第一次尝试代码"><a href="#第一次尝试代码" class="headerlink" title="第一次尝试代码"></a>第一次尝试代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; steps(key.length() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ring.length()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = key.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> next = key[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ring.length(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                steps[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ring.length(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (next == ring[k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> dist = <span class="built_in">abs</span>(j - k);</span><br><span class="line">                        <span class="keyword">int</span> step = min(dist, (<span class="keyword">int</span>)ring.length() - dist);</span><br><span class="line">                        steps[i][j] = min(steps[i][j], step + steps[i + <span class="number">1</span>][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps[<span class="number">0</span>][<span class="number">0</span>] + key.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果反思"><a href="#结果反思" class="headerlink" title="结果反思"></a>结果反思</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Freedom%20Trail_test.png?x-oss-process=style/Blog-Normal" alt="第一次测试" title="">                </div>                <div class="image-caption">第一次测试</div>            </figure><p>&emsp;&emsp;经过测试之后，这种方法的确可行，但看了运行结果发现这个算法运行的并不是很快，当ring变得很长时，花费了很多的时间。在逐步调试之后，一个主要的问题就是在很多不必要的状态下进行了计算。比如有些状态始终不会达到的，没有计算的必要，而且这个三重循环就注定了运行时间并不会很短。</p><p>&emsp;&emsp;思考了一下并参考了别人的方法，觉得还是使用递归来逐步计算比较好，因为左旋和右旋只有2种，但key同一个字母的个数却不止2种，状态还是设定不够到位，应该把指针的位置作为i，匹配数作为j，这样计算时就少了一些分叉。</p><p>&emsp;&emsp;比如要找i，如果参照第一种做法，就会遍历所有到i的路径，而第二种做法就只会左旋和右旋到不同i的位置，找出最短的，不必到遍历到多余的i。</p><hr><h3 id="改良后的代码"><a href="#改良后的代码" class="headerlink" title="改良后的代码"></a>改良后的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        steps = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(ring.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(key.length(), INT_MAX));</span><br><span class="line">        <span class="keyword">return</span> rotate(ring, key, <span class="number">0</span>, <span class="number">0</span>) + key.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rotate</span><span class="params">(<span class="built_in">string</span> &amp;ring, <span class="built_in">string</span> &amp;key, <span class="keyword">int</span> pointer, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= key.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (steps[pointer][pos] != INT_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> steps[pointer][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lp = pointer;</span><br><span class="line">        <span class="keyword">int</span> rp = pointer;</span><br><span class="line">        <span class="keyword">while</span> (ring[lp] != key[pos])</span><br><span class="line">        &#123;</span><br><span class="line">            lp--;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (lp &lt; <span class="number">0</span>) <span class="comment">//判断是否越界。</span></span><br><span class="line">            &#123;</span><br><span class="line">                lp = ring.size() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ring[rp] != key[pos])</span><br><span class="line">        &#123;</span><br><span class="line">            rp++;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (rp == ring.size()) <span class="comment">//判断是否越界。</span></span><br><span class="line">            &#123;</span><br><span class="line">                rp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left += rotate(ring, key, lp, pos + <span class="number">1</span>);</span><br><span class="line">        right += rotate(ring, key, rp, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> steps[pointer][pos] = min(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; steps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>&emsp;&emsp;使用了递归避免了三重循环，从0，0开始一直匹配，而且每一个分叉只有左旋和右旋的分叉，减少了分叉的数量从而少计算了很多状态。其中有些状态可以被重复利用，就像很多条路若有一个交叉点，那么后面的最短路径的节点也是交叉的，不必再往后算。这又很像之前的frog jump这道题。修改后的算法居然超越了100%！还是第一次。。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Freedom%20Trail_test2.png?x-oss-process=style/Blog-Normal" alt="优化后的结果" title="">                </div>                <div class="image-caption">优化后的结果</div>            </figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;动态规划有时候感觉并不会这么容易想得到，虽然都知道通常解法是构建状态，确认策略，然后进行顺推或者倒退来得到结果。但不同的问题都有着不同的性质和解法，所以说解决这类问题只能依靠多熟悉这类问题，多优化多修改，第一次往往都得不到最佳的解法的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;514-Freedom-Trail&quot;&gt;&lt;a href=&quot;#514-Freedom-Trail&quot; class=&quot;headerlink&quot; title=&quot;514. Freedom Trail&quot;&gt;&lt;/a&gt;514. Freedom Trail&lt;/h1&gt;&lt;p&gt;week10&lt;/
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://ziquanzhang.ink/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode]  828. Unique Letter String</title>
    <link href="http://ziquanzhang.ink/2018/11/05/LeetCode-828-Unique-Letter-String/"/>
    <id>http://ziquanzhang.ink/2018/11/05/LeetCode-828-Unique-Letter-String/</id>
    <published>2018-11-05T12:39:00.000Z</published>
    <updated>2018-11-05T12:42:19.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="828-Unique-Letter-String"><a href="#828-Unique-Letter-String" class="headerlink" title="828. Unique Letter String"></a>828. Unique Letter String</h1><p>week9</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/unique-letter-string/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A character is unique in string <code>S</code> if it occurs exactly once in it.</p><p>For example, in string <code>S = &quot;LETTER&quot;</code>, the only unique characters are <code>&quot;L&quot;</code> and <code>&quot;R&quot;</code>.</p><p>Let’s define <code>UNIQ(S)</code> as the number of unique characters in string <code>S</code>.</p><p>For example, <code>UNIQ(&quot;LETTER&quot;) =  2</code>.</p><p>Given a string <code>S</code> with only uppercases, calculate the sum of <code>UNIQ(substring)</code> over all non-empty substrings of <code>S</code>.</p><p>If there are two or more equal substrings at different positions in <code>S</code>, we consider them different.</p><p>Since the answer can be very large, return the answer modulo <code>10 ^ 9 + 7</code>.</p><p><strong>Example1:</strong></p><pre><code>Input: &quot;ABC&quot;Output: 10Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.Evey substring is composed with only unique letters.Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10</code></pre><p><strong>Example2:</strong></p><pre><code>Input: &quot;ABA&quot;Output: 8Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1.</code></pre><p><strong>Note:</strong> <code>0 &lt;= S.length &lt;= 10000</code>.</p><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;题意是找出一个字符串中的<strong>所有子串</strong>，再在<strong>每个子串</strong>中统计所有的只出现<strong>一次</strong>的字母的个数，最后统计所有的次数之和进行输出。主要是如何找出所有子串且要计算单独出现的字母个数。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;如果是按照题目的那种例子来算，算出所有的子串，再判断，那么一定非常复杂，不说子串的数量非常多，判断也是一个大问题，最后还要进行统计，这种方法是不可行的，特别是题目给出的字符串最长有1w个字符。</p><p>&emsp;&emsp;既然正向方法不可行，那么可以尝试使用构造的方法，即根据字符串中的每一个字母特殊构造出一个字符串，若该字符串属于字串，则符合+1，因此题目也就转变成了每一个字母包含其的子串有多少个。</p><p>&emsp;&emsp;因为有条件限制，且字母的位置固定，因此可以很轻松的判断包含某个字母的子串有多少个，例如A***A**A,这种，若要判断包含中间的A有多少子串，因为有条件限制不能超过1个A，所以就限制在了***A**之中选择，根据排列组合，左边有4种选择，右边有3种选择，所以子串为3*4 = 12。</p><p>&emsp;&emsp;因此得到方法：将字母左边的其它字母数*右边其它字母数即为子串数目。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniqueLetterString</span><span class="params">(<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; letter[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter[i].push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter[S[i] - <span class="string">'A'</span>].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter[i].push_back(S.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; letter[i].size() - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result += (letter[i][j + <span class="number">1</span>] - letter[i][j]) * (letter[i][j] - letter[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>考虑到有可能在字符串的边界这种情况，因此将边界考虑在内进行计算，从而更加方便进行计算而无需反复判断，和二分法类似。</p></li><li><p>使用了vector数组将不同字母分开，因为这个计算最关键的是找到两边的同种字母和边界来计算出其子串，所以先记录位置再分开计算比较好。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Unique%20Letter%20String_test.png" alt="Unique Letter String_test" title="">                </div>                <div class="image-caption">Unique Letter String_test</div>            </figure><h2 id="最佳解法"><a href="#最佳解法" class="headerlink" title="最佳解法"></a>最佳解法</h2><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniqueLetterString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">26</span>][<span class="number">2</span>], res = <span class="number">0</span>, N = S.length(), mod = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">memset</span>(index, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">52</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = S[i] - <span class="string">'A'</span>;</span><br><span class="line">        res = (res + (i - index[c][<span class="number">1</span>]) * (index[c][<span class="number">1</span>] - index[c][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">        index[c][<span class="number">0</span>] = index[c][<span class="number">1</span>];</span><br><span class="line">        index[c][<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; ++c)</span><br><span class="line">        res = (res + (N - index[c][<span class="number">1</span>]) * (index[c][<span class="number">1</span>] - index[c][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>&emsp;&emsp;在网上的讨论中发现了一个更加快的代码，这个思路和上面的思路相似，都是计算子串数，不过这个用了边记录边算方法，因为我们每次算只需要知道目标位置以及两边的边界即可，这个就是利用了这一点只记录了上两次同字母的位置，加上第三次就可计算中间的子串数。不过这个做法没有算完，要在最后的时候再加上包含最后字母的子串数。</p><p>&emsp;&emsp;这种方法重复利用了空间，减少了遍历的次数，很值得学习。可能有时候这点时间就能决定能不能AC。<a href="https://leetcode.com/problems/unique-letter-string/discuss/128952/One-pass-O(N" target="_blank" rel="noopener">详细的思路分析</a>-Straight-Forward)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这道题主要是锻炼我们思考问题时的转化能力，怎么样把问题转化成简单的问题，逆向思路解决。另外如何计算包含某特定位置的子串也是一种值得思考的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;828-Unique-Letter-String&quot;&gt;&lt;a href=&quot;#828-Unique-Letter-String&quot; class=&quot;headerlink&quot; title=&quot;828. Unique Letter String&quot;&gt;&lt;/a&gt;828. Unique L
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>区块链热身报告</title>
    <link href="http://ziquanzhang.ink/2018/11/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/"/>
    <id>http://ziquanzhang.ink/2018/11/04/区块链热身报告/</id>
    <published>2018-11-04T13:17:00.000Z</published>
    <updated>2018-11-04T13:19:28.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链热身报告"><a href="#区块链热身报告" class="headerlink" title="区块链热身报告"></a>区块链热身报告</h1><p>16340296  张子权</p><h2 id="以太坊的安装、私有链创世区块搭建、私有链节点的加入-选做"><a href="#以太坊的安装、私有链创世区块搭建、私有链节点的加入-选做" class="headerlink" title="以太坊的安装、私有链创世区块搭建、私有链节点的加入(选做)"></a>以太坊的安装、私有链创世区块搭建、私有链节点的加入(选做)</h2><ol><li><p>安装以太坊<br>从<a href="http://ethereum.github.io/go-ethereum/downloads/" target="_blank" rel="noopener">http://ethereum.github.io/go-ethereum/downloads/</a> 下载安装Geth，可能需要在windows下添加环境变量。<br><img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/Block-chain/%E9%98%B6%E6%AE%B51.%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/%E5%AE%89%E8%A3%85%E4%BB%A5%E5%A4%AA%E5%9D%8A.png" alt="安装以太坊"></p></li><li><p>私有链创世区块搭建<br> 新建一个genesis.json，设置创世区块的难度,id等参数。新建文件夹data。<br> 初始化创世区块：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data/ init genesis.json</span><br></pre></td></tr></table></figure><p> 启动节点并进入交互式控制台：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir data --networkid 1008 --ipcdisable --port 1001 --rpcport 8001 --verbosity=4 console 2&gt;&gt;output.log</span><br></pre></td></tr></table></figure></li><li><p>私有链节点的加入<br> 再新建一个节点为data0。<br> 启动节点并进入交互式控制台：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">geth</span> <span class="selector-tag">--datadir</span> <span class="selector-tag">data0</span> <span class="selector-tag">--networkid</span> 1008 <span class="selector-tag">--ipcdisable</span> <span class="selector-tag">--port</span> 1003 <span class="selector-tag">--rpcport</span> 80222  <span class="selector-tag">console</span></span><br></pre></td></tr></table></figure><p> 在第一个节点中使用<code>admin.nodeInfo.enode</code>获取enode。<br> 在第二个节点中添加第一个节点。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.addPeer("enode://e9e7ad186217fbf7b7d7185695dcd17afa73d23e1a1365dd96d01327aee87b2b95af8ca3857ce6b1f6a7d26c58abc19f5e0846787a1d35e21cab7c5fea0cee2a@[::]:1001")</span><br></pre></td></tr></table></figure><p> 再使用admin.peers可得到加入节点的信息。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    caps: ["eth/62", "eth/63"],</span><br><span class="line">    enode: "enode://e9e7ad186217fbf7b7d7185695dcd17afa73d23e1a1365dd96d01327aee87b2b95af8ca3857ce6b1f6a7d26c58abc19f5e0846787a1d35e21cab7c5fea0cee2a@[::]:1001",</span><br><span class="line">    id: "e4a6cb32cfb6b641dd2606bdb67571f63ff80ff1fe4883c1aa46cd5b89e110eb",</span><br><span class="line">    name: "Geth/v1.8.17-stable-8bbe7207/windows-amd64/go1.11.1",</span><br><span class="line">    network: &#123;</span><br><span class="line">    inbound: false,</span><br><span class="line">    localAddress: "127.0.0.1:18752",</span><br><span class="line">    remoteAddress: "127.0.0.1:1001",</span><br><span class="line">    static: true,</span><br><span class="line">    trusted: false</span><br><span class="line">    &#125;,</span><br><span class="line">    protocols: &#123;</span><br><span class="line">    eth: &#123;</span><br><span class="line">        difficulty: 85380105,</span><br><span class="line">        head: "0xd2c073c35fb027d8dd8fe4d95174bc82ca93d96599dfb05e8deee320631621f0",</span><br><span class="line">        version: 63</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li></ol><h2 id="对-getBlock-中所得区块的各个字段进行解释"><a href="#对-getBlock-中所得区块的各个字段进行解释" class="headerlink" title="对 getBlock 中所得区块的各个字段进行解释"></a>对 getBlock 中所得区块的各个字段进行解释</h2><div class="table-container"><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">类型</th><th>意义</th></tr></thead><tbody><tr><td style="text-align:left">difficulty</td><td style="text-align:left">BigNumber</td><td>表示当前区块的难度，根据前一个区块的难度和时间戳计算得到，可知当前区块1难度为131072</td></tr><tr><td style="text-align:left">extraData</td><td style="text-align:left">String</td><td>指的是附加信息，可以根据自己的需要填写信息。32字节以内的字节数组。</td></tr><tr><td style="text-align:left">gasLimit</td><td style="text-align:left">Number</td><td>表示当前区块允许使用的最大gas，指这笔交易最多只能给矿工这么多gas，若用不完则返回多出的gas返回，但如果gaslimit不足以支付交易，那么不会退回，因为以太坊规定每笔交易gas最少为21000，所以一定要大于21000。同理若合约的gaslimit小于区块的gaslimit则部署不了。</td></tr><tr><td style="text-align:left">gasUsed</td><td style="text-align:left">Number</td><td>和gasLimit相对，为当前区块所累积使用的gas值。</td></tr><tr><td style="text-align:left">hash</td><td style="text-align:left">String</td><td>指该区块的哈希值，当区块等待被区块链确认时，则为null，可以认为是区块在整个区块链的索引。</td></tr><tr><td style="text-align:left">logsBloom</td><td style="text-align:left">String</td><td>日志Bloom过滤器，信息包含在每个日志入口, 来自交易列表中每个交易的接受者。</td></tr><tr><td style="text-align:left">miner</td><td style="text-align:left">String</td><td>表示打包这一区块的矿工的地址。</td></tr><tr><td style="text-align:left">mixHash</td><td style="text-align:left">String</td><td>混合哈希，与nonce进行哈希运算，证明已经付出了足够的工作量。</td></tr><tr><td style="text-align:left">nonce</td><td style="text-align:left">String</td><td>一个随机数64位哈希，表示该矿工找到的符合条件的nonce值。</td></tr><tr><td style="text-align:left">number</td><td style="text-align:left">Number</td><td>为区块编号，指该区块为第几个区块。</td></tr><tr><td style="text-align:left">parentHash</td><td style="text-align:left">String</td><td>父哈希，指上一个区块的哈希值。因为创世区块没父区块，所以这个值为0。</td></tr><tr><td style="text-align:left">receiptsRoot</td><td style="text-align:left">String</td><td>交易完成后，由交易收据，日志内容构成的数据的字典树根节点哈希。</td></tr><tr><td style="text-align:left">sha3Uncles</td><td style="text-align:left">String</td><td>类似上一个，指由叔区块哈希构成的字典树的根节点哈希。</td></tr><tr><td style="text-align:left">size</td><td style="text-align:left">Number</td><td>当前这个区块的字节大小。</td></tr><tr><td style="text-align:left">stateRoot</td><td style="text-align:left">String</td><td>状态字典树根节点的哈希。</td></tr><tr><td style="text-align:left">timestamp</td><td style="text-align:left">Number</td><td>指当前该区块初始化时的Unix时间戳。</td></tr><tr><td style="text-align:left">totalDifficulty</td><td style="text-align:left">Number</td><td>到当前区块为止，所积累的所有区块难度之和。</td></tr><tr><td style="text-align:left">transactions</td><td style="text-align:left">数组</td><td>当前区块所包含的交易。</td></tr><tr><td style="text-align:left">transactionsRoot</td><td style="text-align:left">String</td><td>包含所有交易的交易字典树的根节点哈希值。</td></tr><tr><td style="text-align:left">Uncles</td><td style="text-align:left">数组</td><td>包含当前区块的所以叔区块。</td></tr></tbody></table></div><h2 id="对日志输出进行解释"><a href="#对日志输出进行解释" class="headerlink" title="对日志输出进行解释"></a>对日志输出进行解释</h2><ul><li><p>初始化区块链，分配文件夹和空间，写入创世块，持久化字典树。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|15:30:01.915] Allocated cache and file handles         database="D:\\Program Files\\Geth\\data\\geth\\chaindata" cache=16 handles=16</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:30:01.940] Writing custom genesis block</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:30:01.941] Persisted trie from memory database      nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:30:01.941] Successfully wrote genesis state         database=chaindata hash=5e1fc7…790e0</span><br></pre></td></tr></table></figure></li><li><p>开始连接时，初始化以太坊协议，载入最近的区块，重新加载交易和生成交易日志。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|15:31:05.759] Initialising Ethereum protocol           versions="[63 62]" network=1008</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:31:05.759] Loaded most recent local header          number=0 hash=5e1fc7…790e0 td=131072 age=49y6mo2w</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:31:05.760] Loaded most recent local full block      number=0 hash=5e1fc7…790e0 td=131072 age=49y6mo2w</span><br><span class="line">INFO [11-04|15:31:05.760] Loaded most recent local fast block      number=0 hash=5e1fc7…790e0 td=131072 age=49y6mo2w</span><br><span class="line"></span><br><span class="line">DEBUG[11-04|15:31:05.760] Reinjecting stale transactions           count=0</span><br><span class="line"></span><br><span class="line">INFO [11-04|15:31:05.762] Regenerated local transaction journal    transactions=0 accounts=0</span><br></pre></td></tr></table></figure></li><li><p>输入exit关闭连接，之后将缓存中的状态写入磁盘持久化数据，关闭区块链，关闭协议和交易池，最后关闭数据库。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|17:11:41.533] Writing cached state to disk             block=454 hash=4713ec鈥?7d4ca root=a006ff鈥e94ea</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Persisted trie from memory database      nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gc</span><br><span class="line">    time=0s livenodes=1 livesize=0.00B</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Blockchain manager stopped</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Stopping Ethereum protocol</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Ethereum protocol stopped</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Transaction pool stopped</span><br><span class="line"></span><br><span class="line">INFO [11-04|17:11:41.533] Database closed                          database="D:\\Program Files\\Geth\\data\\geth\\chain</span><br><span class="line">data"</span><br></pre></td></tr></table></figure></li><li><p>矿工挖矿，打包新区块，开采潜在的区块。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|17:30:48.082] Commit new mining work                   number=593 sealhash=108a77…bbb5d6 uncles=0 txs=0 gas=0 fees=0 elapsed=35.904ms</span><br><span class="line">INFO [11-04|17:30:49.212] Successfully sealed new block            number=593 sealhash=108a77…bbb5d6 hash=c52790…332920 elapsed=1.166s</span><br><span class="line">INFO [11-04|17:30:49.217] 🔨 mined potential block                  number=593 hash=c52790…332920</span><br></pre></td></tr></table></figure></li><li><p>提交交易。</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|18:25:09.342] Setting new local account                address=0x15b97213fB8ee04D2ed53113E41035FEaE88461e</span><br><span class="line">INFO [11-04|18:25:09.346] Submitted transaction                    fullhash=0x889aa5bb7bc45463a5f59012b2ac15abdce71542a48bc6a6be91969c48eac6a5 recipient=0x6a949Cd94E739d035d13c2242B32093553567361</span><br><span class="line"><span class="string">"0x889aa5bb7bc45463a5f59012b2ac15abdce71542a48bc6a6be91969c48eac6a5"</span></span><br></pre></td></tr></table></figure></li><li><p>随后通过挖矿发现有一gas=420000的区块。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|18:32:42.760] Commit new mining work                   number=607 sealhash=916dea…38331b uncles=0 txs=2 gas=42000 fees=4.2e-05 elapsed=8.943ms</span><br></pre></td></tr></table></figure></li><li><p>添加节点。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO [11-04|18:39:56.578] Block synchronisation started</span><br><span class="line">INFO [11-04|18:39:56.709] Imported new chain segment               blocks=26 txs=7 mgas=0.126 elapsed=111.730ms mgasps=1.128 number=607 hash=d2c073…1621f0 age=7m14s   cache=17.84kB ignored=2</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写简单的智能合约，在-remix-下进行调试，并部署在链上进行调用"><a href="#编写简单的智能合约，在-remix-下进行调试，并部署在链上进行调用" class="headerlink" title="编写简单的智能合约，在 remix 下进行调试，并部署在链上进行调用"></a>编写简单的智能合约，在 remix 下进行调试，并部署在链上进行调用</h2><h3 id="编写简单的智能合约"><a href="#编写简单的智能合约" class="headerlink" title="编写简单的智能合约"></a>编写简单的智能合约</h3><p>编写一个类似与复读机的东西，发送字符串保存，之后复读发送的话。</p><p>solidity代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract AI &#123;</span><br><span class="line">    string box;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">send</span><span class="params">(string s)</span> <span class="keyword">public</span> </span>&#123;</span><br><span class="line">        box = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">clear</span><span class="params">()</span> <span class="keyword">public</span></span>&#123;</span><br><span class="line">        box = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">receive</span><span class="params">()</span> <span class="keyword">public</span> constant <span class="title">returns</span> <span class="params">(string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">greet</span><span class="params">()</span> <span class="keyword">public</span> constant <span class="title">returns</span> <span class="params">(string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进行调试部署调用"><a href="#进行调试部署调用" class="headerlink" title="进行调试部署调用"></a>进行调试部署调用</h3><ol><li><p>部署合约<br> <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/Block-chain/%E9%98%B6%E6%AE%B51.%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/%E9%83%A8%E7%BD%B2%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6.png" alt="部署合约"><br> 进行挖矿后成功部署。</p></li><li><p>greet<br> <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/Block-chain/%E9%98%B6%E6%AE%B51.%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/greet.png" alt="greet"></p></li><li><p>发送信息，产生交易，挖矿后交易成功。<br> <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/Block-chain/%E9%98%B6%E6%AE%B51.%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/%E5%8F%91%E9%80%81string.png" alt="send"></p></li><li><p>交易成功后更新里面的string，再用receive得到刚刚的消息。<br> <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/Block-chain/%E9%98%B6%E6%AE%B51.%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A/receive.png" alt="receive"></p></li><li><p>清除消息，也需要产生交易，然后挖矿使交易成功。</p></li></ol><h2 id="对交易的字段进行解释"><a href="#对交易的字段进行解释" class="headerlink" title="对交易的字段进行解释"></a>对交易的字段进行解释</h2><p>根据以上3的发送消息的交易进行解释。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth.getTransaction("0xeb7a55e1760ecc986f813c881b76ab12b812bc611f8f6b9cacb69248438b50ec")</span><br><span class="line">&#123;</span><br><span class="line">    blockHash: "0x06258165d31d4ea7ed945fa430d8e25f75690c0ae20ca4d2ae8f6de40576d261",</span><br><span class="line">    blockNumber: 642,</span><br><span class="line">    from: "0x15b97213fb8ee04d2ed53113e41035feae88461e",</span><br><span class="line">    gas: 43406,</span><br><span class="line">    gasPrice: 1000000000,</span><br><span class="line">    hash: "0xeb7a55e1760ecc986f813c881b76ab12b812bc611f8f6b9cacb69248438b50ec",</span><br><span class="line">    input: "0x66792ba10000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000ce5bc80e5a78be5a48de8afbb0000000000000000000000000000000000000000",</span><br><span class="line">    nonce: 14,</span><br><span class="line">    r: "0x3892abe334fbe797ce57155373c9c36860121d143950f873e554dc37321847d",</span><br><span class="line">    s: "0x55eea1e92c492bd89f7db381fda08ae795fdc7abdbcff4c98f897cae94edae7c",</span><br><span class="line">    to: "0x2eb0f4a6c064c51033dbc5977973bcb6702a9cdd",</span><br><span class="line">    transactionIndex: 0,</span><br><span class="line">    v: "0x37",</span><br><span class="line">    value: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">类型</th><th>意义</th></tr></thead><tbody><tr><td style="text-align:left">blockHash</td><td style="text-align:left">String</td><td>交易所处区块的哈希值</td></tr><tr><td style="text-align:left">blockNumber</td><td style="text-align:left">Number</td><td>当前交易所处在区块的编号</td></tr><tr><td style="text-align:left">from</td><td style="text-align:left">String</td><td>发起交易的账户（地址）</td></tr><tr><td style="text-align:left">gas</td><td style="text-align:left">Number</td><td>完成这笔交易所需要的gas</td></tr><tr><td style="text-align:left">gasPrice</td><td style="text-align:left">Number</td><td>当前每个gas所需的花费</td></tr><tr><td style="text-align:left">hash</td><td style="text-align:left">String</td><td>当前交易的哈希值</td></tr><tr><td style="text-align:left">input</td><td style="text-align:left">String</td><td>部署智能合约交易的16进制代码，合约调用相关的二进制信息</td></tr><tr><td style="text-align:left">nonce</td><td style="text-align:left">Number</td><td>相当于发起人的交易序号，每发送一笔交易，nonce+1，放置交易重复进行</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">String</td><td>发起人EOA的ECDSA签名的三个组成部分</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">String</td><td>发起人EOA的ECDSA签名的三个组成部分</td></tr><tr><td style="text-align:left">to</td><td style="text-align:left">String</td><td>目标以太坊地址</td></tr><tr><td style="text-align:left">transactionIndex</td><td style="text-align:left">Number</td><td>交易索引</td></tr><tr><td style="text-align:left">v</td><td style="text-align:left">String</td><td>发起人EOA的ECDSA签名的三个组成部分</td></tr><tr><td style="text-align:left">values</td><td style="text-align:left">Number</td><td>要发送到目的地址的以太币数</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区块链热身报告&quot;&gt;&lt;a href=&quot;#区块链热身报告&quot; class=&quot;headerlink&quot; title=&quot;区块链热身报告&quot;&gt;&lt;/a&gt;区块链热身报告&lt;/h1&gt;&lt;p&gt;16340296  张子权&lt;/p&gt;
&lt;h2 id=&quot;以太坊的安装、私有链创世区块搭建、私有链节点的加
      
    
    </summary>
    
      <category term="Block-Chain" scheme="http://ziquanzhang.ink/categories/Block-Chain/"/>
    
    
      <category term="ethereum" scheme="http://ziquanzhang.ink/tags/ethereum/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 45. Jump Game II</title>
    <link href="http://ziquanzhang.ink/2018/10/28/LeetCode-45-Jump-Game-II/"/>
    <id>http://ziquanzhang.ink/2018/10/28/LeetCode-45-Jump-Game-II/</id>
    <published>2018-10-28T13:57:00.000Z</published>
    <updated>2018-10-28T13:59:09.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><p>week8</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p><strong>Note:</strong></p><ul><li>The number of stones is ≥ 2 and is &lt; 1,100.</li><li>Each stone’s position will be a non-negative integer &lt; 231.</li><li>The first stone’s position is always 0.</li></ul><p><strong>Example:</strong></p><pre><code>Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2.    Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre><p><strong>Note:</strong></p><pre><code>You can assume that you can always reach the last index.</code></pre><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;这道题目十分简单，就是给予一个数组，使得一开始在数组的首元素中，能够跳越到最后一项，而每项中的数字即跳跃的极限范围。给出最快到达数组尾的步数。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;和上一周所做的青蛙跳十分类似，但又不太一样，因为这次的只给出了跳越的极限，所以范围可以选择0~x，使得几乎都可以到达终点。</p><p>&emsp;&emsp;既然是这样的话，那么就可以不需要进行分支预测和判断了，直接使用贪心算法，贪心策略并不是每次都走到最远的距离，而是根据到达的顶点之后所能达到的最大距离。这样就能保证每一个的距离都是由上一个的最远距离而来。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxjump = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= maxjump &amp;&amp; index &lt; nums.size() - <span class="number">1</span>;)&#123;</span><br><span class="line">            steps++;</span><br><span class="line">            <span class="keyword">if</span>(maxjump &gt;= nums.size() <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> nextjump = maxjump;</span><br><span class="line">            <span class="keyword">int</span> start = index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = nextjump; i &gt;= start; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i + nums[i] &gt; maxjump)&#123;</span><br><span class="line">                    maxjump = i + nums[i];</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>这个贪心策略的证明可以根据递归来说明，即已经到达了终点，那么要寻找达到终点的最远的起点，不断地往前回溯，最后可以得知每一次判断下一个顶点的最远距离来选择下一个跳点，能够最快到达终点。</p></li><li><p>这个算法同青蛙跳石头一样可以进行优化，我们可以选择从当前可跳越的最远距离的顶点开始遍历，那么很有可能第一次就得到最佳跳点，就不用经常进行赋值运算。经过优化后的算法可从12ms降为8ms。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Jump%20Game%20II_test.png" alt="Jump Game II_test" title="">                </div>                <div class="image-caption">Jump Game II_test</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;最近刚学习贪心算法，恰好用一下，这个题目的关键之处在于怎么去证明贪心是可行的，有可能不一定贪心就可以，就像上一周青蛙跳的题目，使用贪心算法时一定要注意是否满足条件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;45-Jump-Game-II&quot;&gt;&lt;a href=&quot;#45-Jump-Game-II&quot; class=&quot;headerlink&quot; title=&quot;45. Jump Game II&quot;&gt;&lt;/a&gt;45. Jump Game II&lt;/h1&gt;&lt;p&gt;week8&lt;/p&gt;
&lt;p&gt;难度：
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 403. Frog Jump</title>
    <link href="http://ziquanzhang.ink/2018/10/19/LeetCode-403-Frog-Jump/"/>
    <id>http://ziquanzhang.ink/2018/10/19/LeetCode-403-Frog-Jump/</id>
    <published>2018-10-19T08:13:00.000Z</published>
    <updated>2018-10-19T08:16:22.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="403-Frog-Jump"><a href="#403-Frog-Jump" class="headerlink" title="403. Frog Jump"></a>403. Frog Jump</h1><p>week7</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p><p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p><p>If the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.</p><p><strong>Note:</strong></p><ul><li>The number of stones is ≥ 2 and is &lt; 1,100.</li><li>Each stone’s position will be a non-negative integer &lt; 231.</li><li>The first stone’s position is always 0.</li></ul><p><strong>Example1:</strong></p><pre><code>[0,1,3,5,6,8,12,17]There are a total of 8 stones.The first stone at the 0th unit, second stone at the 1st unit,third stone at the 3rd unit, and so on...The last stone at the 17th unit.Return true. The frog can jump to the last stone by jumping1 unit to the 2nd stone, then 2 units to the 3rd stone, then2 units to the 4th stone, then 3 units to the 6th stone,4 units to the 7th stone, and 5 units to the 8th stone.</code></pre><p><strong>Example2:</strong></p><pre><code>[0,1,2,3,4,8,9,11]Return false. There is no way to jump to the last stone asthe gap between the 5th and 6th stone is too large.</code></pre><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;著名的青蛙跳石头问题，在大一的时候一次ACM比赛中碰到一次，貌似是原题，结果很显然扑街了，现在看到题目才算正式理解了题目。。。想来当时没有学习什么数据结构也是做不出的了，暴力AK明显会timelimit。<br>&emsp;&emsp;青蛙跳石头的题意是有一只青蛙要过河，河流分成X个部分，有的地方有石头，有的没有。而这只青蛙要连续跳过去，可能这只青蛙的手刹有点毛病，每当跳过K个单位时，下一次跳越要是K-1、K或者K+1个单位，并且只能向前。<br>&emsp;&emsp;一开始的理解是只要判断下一块石头是否在跳越范围内就行了，但注意的是青蛙可以飞过某一块石头，所以就有很多种跳越方式，假设有两条路径能到达点A，通过不同路径后到达点A后，其下一步的跳越范围（能力）也会不一样，所以情况会很复杂。</p><hr><h2 id="第一次解题思路"><a href="#第一次解题思路" class="headerlink" title="第一次解题思路"></a>第一次解题思路</h2><p>&emsp;&emsp;由于青蛙的选择路径的多变，会引起后续的跳越，因此它的选择分支是从第一次就开始了，试想一下每个分支又会衍生不同的分支，那不就是一颗路径树了吗，只要遍历这一棵树，找到某一路径可以到达终点即可，因为只需要得出青蛙是否能过河的结论，所以无需遍历所有路径（除非所有路径都不能到达）。<br>&emsp;&emsp;为了尽快地解决问题，很明显是用深度遍历的，当得到一条路径后，马上返回true节省时间。所以使用递归的方式，遍历所有状态。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        stoness = stones;</span><br><span class="line">        <span class="keyword">return</span> cross(stoness.begin(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator start, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == stoness.end()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = dis - <span class="number">1</span>; i &lt;= dis+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(start+<span class="number">1</span>,stoness.end(),i+*start);</span><br><span class="line">            <span class="keyword">if</span>(it != stoness.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cross(it,i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;stoness;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果与反思"><a href="#结果与反思" class="headerlink" title="结果与反思"></a>结果与反思</h3><p>&emsp;&emsp;在过了example后，提交的检测超时了，例子是[1..998,99999999],这个极端的例子展示了这个算法的弱点，没有根据搜索得的信息加快速度，每次都搜索到了998这个节点，但由于最后一个点不可到达，所以都在最后一步终止，浪费了大量的时间，所以我们要采取一种措施及时止损。</p><h2 id="第二次解题思路"><a href="#第二次解题思路" class="headerlink" title="第二次解题思路"></a>第二次解题思路</h2><p>&emsp;&emsp;采用遍历路径树是没有错的，因为我们需要验证每一条路径是否能通往最后一个节点，但我们不能重复判断同一个状态多次，因为每条路径中有着许多相同的状态，即达到点相同，且下一步的跳越范围相同，如果我们在一条路径中已经得知该状态是否能达到终点，就可以在其它路径中引用进行快速判断。就是如一个节点不通，则经过该节点的所有路径都不通。</p><p>&emsp;&emsp;具体方法是维护一个哈希表保存状态的可行性，因为一个状态有两个属性，一是点的位置，二是上一步跳越距离，因为石头数量有限，可以通过左移取或，将两个值合并起来得到一个唯一的值，从而确定一个唯一的状态，保存该状态是否能达到终点。</p><h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        stoness = stones;</span><br><span class="line">        <span class="keyword">return</span> cross(stoness.begin(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator start, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == stoness.end()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> key = *start | dis&lt;&lt;<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">if</span> (status.count(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> status[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = dis + <span class="number">1</span>; i &gt;= dis<span class="number">-1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(start+<span class="number">1</span>,stoness.end(),i+*start);</span><br><span class="line">            <span class="keyword">if</span>(it != stoness.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cross(it,i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> status[key] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status[key] = <span class="literal">false</span>;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;stoness;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; status;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>在查询下一个跳越点时，可以使用循环来寻找，但我觉得如果跳越距离很大，那么就要遍历很多个位置，因此使用find直接在vector中寻找对应k-1，k，k+1距离的点会更加快。</p></li><li><p>在看了一下别人的做法中，发现可以先在两个点之后，判断是否后一个点是前一个点的两倍还多，即stone[i]&gt;2*stone[i-1]，若存在这一情况，那么必定不能到达，因为青蛙在2次跳越后，不可能跳越2倍的距离，而且这个数组又是升序的，所以不可逾越。可以去掉很多极端情况。</p></li><li><p>看了一下题目的评论，有一个评论说从步数大的开始遍历会更快得到答案，想了一下似乎是这样的，因位较小的步数最终很有可能走到大步数的状态，中间多出了很多不必要的状态，改成i—后，从24ms提升到了16ms，感觉改善很客观。居然能到95.46%了。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ziquanzhang-image.oss-cn-shenzhen.aliyuncs.com/LeetCode/Frog%20Jump_test.PNG" alt="Frog Jump_test" title="">                </div>                <div class="image-caption">Frog Jump_test</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这个题目的关键之处在于如何利用已知的信息进行搜索，而不是采用盲目搜索的方式，在搜索过程中，发现一个点不通则将之后的路径封掉，对信息的复用，极大加快算法的速度，另外一些顺序的选择也很有可能影响速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;403-Frog-Jump&quot;&gt;&lt;a href=&quot;#403-Frog-Jump&quot; class=&quot;headerlink&quot; title=&quot;403. Frog Jump&quot;&gt;&lt;/a&gt;403. Frog Jump&lt;/h1&gt;&lt;p&gt;week7&lt;/p&gt;
&lt;p&gt;难度：Hard&lt;/p&gt;
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 297. Serialize and Deserialize Binary Tree</title>
    <link href="http://ziquanzhang.ink/2018/10/14/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/"/>
    <id>http://ziquanzhang.ink/2018/10/14/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/</id>
    <published>2018-10-14T08:38:00.000Z</published>
    <updated>2018-10-14T08:39:41.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h1><p>week6</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/24-game/description/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Example:</strong></p><pre>You may serialize the following tree:    1   / \  2   3     / \    4   5as "[1,2,3,null,null,4,5]"</pre><p><strong>Clarification:</strong> The above format is the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener">how LeetCode serializes a binary tree.</a> You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;题目的意思是将一棵树序列化为字符串，而且序列化后的树能够经过反序列化变为原来的树结构。序列化的意思是将状态信息转化为可以存储和传输的形式，这在很多场合都能够用到，可以使自定义对象持久化，方便传输对象，以及便于程序维护等等。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;题目已经给出了LeetCode所用的二叉树的序列化的形式，即将二叉树的每个节点的值存在一个字符串中，用标点符号隔开。观察其顺序可以发现是使用分层方式来构造的，因此我们可以用分层遍历的方式来构造这个字符串，然后再还原。</p><p>&emsp;&emsp;使用分层遍历，构造一个队列存储遍历的节点并将子节点放在队列中，从而逐层遍历，构造字符串，注意也要把空节点放进去，否则将无法还原为原来的树。</p><p>&emsp;&emsp;得到字符串并以“，”为分割点分割成不同的字符串节点，然后使用队列构造回原来的树。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> sertree;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">            TreeNode* node = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(sertree.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sertree += <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                sertree += <span class="string">"null"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sertree += <span class="built_in">std</span>::to_string(node-&gt;val);</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sertree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; treeNodes = split(data,<span class="string">","</span>);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(atoi(treeNodes[<span class="number">0</span>].c_str()));</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="built_in">queue</span>; </span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; treeNodes.size(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">            TreeNode* node = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="keyword">if</span>(treeNodes[i] != <span class="string">"null"</span>)&#123;</span><br><span class="line">                TreeNode* left = <span class="keyword">new</span> TreeNode(atoi(treeNodes[i].c_str()));</span><br><span class="line">                node-&gt;left = left;</span><br><span class="line">                <span class="built_in">queue</span>.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(treeNodes[i+<span class="number">1</span>] != <span class="string">"null"</span>)&#123;</span><br><span class="line">                TreeNode* right = <span class="keyword">new</span> TreeNode(atoi(treeNodes[i+<span class="number">1</span>].c_str()));</span><br><span class="line">                node-&gt;right = right;</span><br><span class="line">                <span class="built_in">queue</span>.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delim) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span> == str) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先将要切割的字符串从string类型转换为char*类型</span></span><br><span class="line">        <span class="keyword">char</span> * strs = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() + <span class="number">1</span>] ;</span><br><span class="line">        <span class="built_in">strcpy</span>(strs, str.c_str()); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * d = <span class="keyword">new</span> <span class="keyword">char</span>[delim.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(d, delim.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *p = strtok(strs, d);</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = p; <span class="comment">//分割得到的字符串转换为string类型</span></span><br><span class="line">            res.push_back(s); <span class="comment">//存入结果数组</span></span><br><span class="line">            p = strtok(<span class="literal">NULL</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>注意c++中的string中没有split这个函数，所以要自己写一个split函数，使用c++里的strtok方法，先将字符串转化成Char数组类型，（注意char*最后有一个终止符，length+1），然后调用这个方法来处理char数组，通过循环进行逐步分割，再变成string，最后传出结果vector;</p></li><li><p>反序列化为树结构时，需要注意要去除空节点。否则将会出现访问空节点的错误，另外因为存放了null，所以每一次可以同时访问左右两个节点。</p></li><li><p>除了使用分层序列化之外，还有许多方法，比如使用深度+递归，广度遍历也可以，只要能够做到反序列化从转化为原来的树结构即可。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在这个题目中，我发现JAVA和C++其实很大区别的，写多了JAVA之后，发现许多方法都在c++没有提供，比如split，还有许多很方便使用的Likedlist等等数据结构。所以在JAVA中许多包装的方法还是挺好用的，以前还觉得很相似，但是现在发现在应用上的便利性上差距挺大的，所以遇到问题可以先使用JAVA来完成一下，确定解决的方法，然后再使用C++来实现。</p><p>&emsp;&emsp;看了一下除此之外有人使用map<long,treenode*>来进行存储，直接偷鸡使用全局变量存储状态。。。不算是序列化。而且题目已经标明了不可用存储状态的做法了。</long,treenode*></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;297-Serialize-and-Deserialize-Binary-Tree&quot;&gt;&lt;a href=&quot;#297-Serialize-and-Deserialize-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;297. Seria
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 679. 24 Game</title>
    <link href="http://ziquanzhang.ink/2018/10/07/LeetCode-679-24-Game/"/>
    <id>http://ziquanzhang.ink/2018/10/07/LeetCode-679-24-Game/</id>
    <published>2018-10-07T12:49:00.000Z</published>
    <updated>2018-10-07T12:56:32.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-Game"><a href="#24-Game" class="headerlink" title="24 Game"></a>24 Game</h1><p>week5</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/24-game/description/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.</p><p><strong>Example1:</strong></p><pre>Input: [4, 1, 8, 7]Output: TrueExplanation: (8-4) * (7-1) = 24</pre><p><strong>Example2:</strong></p><pre>Input: [1, 2, 1, 2]Output: False</pre><p><strong>Note:</strong></p><pre><code>1.The division operator / represents real division, not integer division. For example, 4 / (1 - 2/3) = 12.2. Every operation done is between two numbers. In particular, we cannot use - as a unary operator. For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.3. You cannot concatenate numbers together. For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.</code></pre><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;这道题目的意思很明显，就是要解决24点的问题，随机给出4个数，仅能用四则运算，若得到24点则输出正确，否则输出错误。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;解决这道题一开始是使用穷举法，将所有的可能都列举出来，然后进行判断，但每一次运算只能减少一个数，而一开始有4个数，4个运算法则，而四则运算中，乘和加是和两个数顺序无关的，那么结果有<script type="math/tex">C^2_4*6*C^2_3*6*C^2_2*6 = 3888</script><br>种可能，有点多，不可能用代码都列出来。<br>&emsp;&emsp;所以接下来考虑利用递归的方式，将每一种方法都遍历一遍，类似于深度搜索的方法，构成一棵树，根为4个数，每个分支代表一次运算，其子节点数的个数-1，因此树的高度为4，用深度遍历的原因是我们只需要把这个24点有无解输出就可以了，不需要输出解甚至所有的解，所以每次遍历都要达到高度4，以便最快得到一个解。<br>&emsp;&emsp;采用递归的方式能够更好的遍历，当一个解不符合时，马上退回上一个状态，寻找下一个解，这里使用vector存储得到的解，当不符合时，弹出得到的运算数，回到上一状态。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgePoint24</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dnums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            dnums.push_back((<span class="keyword">double</span>)val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(dnums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(nums[<span class="number">0</span>] - <span class="number">24</span>) &lt; <span class="number">1e-6</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;card;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; size; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k != i &amp;&amp; k != j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        card.push_back(nums[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(l == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        card.push_back(nums[i]+nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        card.push_back(nums[i]*nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        card.push_back(nums[i]-nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">3</span> &amp;&amp; nums[j]!= <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        card.push_back(nums[i]/nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(dfs(card))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    card.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>因为所给的数的类型是int，因此在运算时要将其转成double类型方便进行乘除运算，否则会出现较大误差，并且判断是否为24点时因计算机的运算可能存在误差，所以要根据其和24点的误差小于一定值来判断。</p></li><li><p>因为在加减乘除中，加和乘对于数作为被加/乘数和加/乘数的结果是无影响的，因此，可以跳过2次运算，这样相当于每个节点原本8个子节点缩减为6个子节点，大大减少其分支，一开始以为没少多少，但是由于树高为4，算出的解能少3/4，极大减少时间。</p></li><li><p>加减乘除的顺序可以调转，也可以是先做加运算一直做到头，再做其它运算，也是可以的，但是个人觉得运算混搭可能会加快得到解的速度，即得到解的概率会大一些，单一进行运算很难得到24点。又由于其运算结果个数并不多，所以感觉使用启发式搜索并没有太大改进，判断时间可能使搜索时间变得更多。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;思路主要是来源于题目写了一个tag为“depth-first search”让我有了一点思路，做这一些判断等题目，若是要进行所有结果的遍历，那么最好的方法就是进行搜索，搜索主要就是用到了树的遍历，即遍历状态。如果状态数过多，那么使用启发式搜索要比盲目搜索更好，而盲目搜索也要根据目的来确定，启发式搜索的难点就在于调参，确定一个搜索方向，而这道题因方向难以确定，而状态数不多，因此才采用深度搜索。</p><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..."></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;24-Game&quot;&gt;&lt;a href=&quot;#24-Game&quot; class=&quot;headerlink&quot; title=&quot;24 Game&quot;&gt;&lt;/a&gt;24 Game&lt;/h1&gt;&lt;p&gt;week5&lt;/p&gt;
&lt;p&gt;难度：Hard&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetc
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 124. Binary Tree Maximum Path Sum</title>
    <link href="http://ziquanzhang.ink/2018/09/30/LeetCode-124-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://ziquanzhang.ink/2018/09/30/LeetCode-124-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2018-09-30T02:17:00.000Z</published>
    <updated>2018-09-30T02:21:12.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h1><p>week4</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p><strong>Example1:</strong></p><pre>Input: [1,2,3]       1      / \     2   3Output: 6</pre><p><strong>Example2:</strong></p><pre>Input: [-10,9,20,null,null,15,7]   -10   / \  9  20    /  \   15   7Output: 42</pre><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;这道题目要求找出一颗二叉树中的得到最大数之和的一条路径，路径中的头和尾可以是二叉树中的任意一节点。这也就是说除了可以经过根节点外，还可以是二叉树里任意子树，只要得到的和为最大。</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>&emsp;&emsp;首先想到的是用递归的算法，来算出每一个节点作为根节点所得到的最大路径和，这和书上第四章的某道题目有点相像：已知两顶点，求出两个顶点存在多少条路径。当时我们可以使用递归方式分别求出上一层到下一层节点有多少条路径，逐步计算出到达每一层的路径，最后得到总的路径数。<br>&emsp;&emsp;这道题目也是这样，子树的最大路径和可以是左子树+根+右子树等等，但其作为上一层的子节点只能是左子树/右子树+根。因此我们判断长度和返回到上一层的值是不一样的。即<code>maxNum = max(leftNum + rightNum + node-&gt;val,maxNum);</code>(若左右子树<0，则设其为0)和返回的值`return node-="">val + sumNum;`</0，则设其为0)和返回的值`return></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxNum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        sumPath(root);</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumPath</span><span class="params">(TreeNode * node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftNum = sumPath(node-&gt;left);<span class="comment">//求左右子节点的最大路径和</span></span><br><span class="line">        <span class="keyword">int</span> rightNum = sumPath(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftNum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            leftNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightNum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rightNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sumNum = max(leftNum,rightNum);</span><br><span class="line">        maxNum = max(leftNum + rightNum + node-&gt;val,maxNum);<span class="comment">//每一次和原本的值作比较</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + sumNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>有可能存在只有一个节点，所以一开始最大和设为根节点的值，也可以设置成INT_MIN，因为可能最终的值是负数。</p></li><li><p>因为不一定经过根节点的就是路径最大和，而且每一颗子树都有可能是目标树或者一个特别大的节点，所以每次递归都要进行一次比较，以求得最大的值。</p></li><li><p>做完之后发现代码运行好像很慢，比较了一下和大佬的代码，发现还是写的太复杂了一点，有一些判断根本是不必要的，比如判断是否&lt;0等，直接用max取最大的就可以了，因为负数不是不合法的，不会产生什么逻辑错误。</p></li><li><p>此外发现大佬的代码中写了这么一句速度看起来比我的快不少。。。在网上查了下之后似乎是cin、cout效率低的原因是要把东西输入到缓冲区在进行输入输出，这一句语句可以取消其缓冲，使得和scanf、printf的效率差不多。。这也解释了为什么以前有时候用cin和cout会超时，而用scanf、printf不会。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fast = []() &#123;ios_base::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;附上大佬简洁的代码。。但感觉阅读上可能并不会很快，可能有时候需要在简洁和易懂中作出取舍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fast = []() &#123;ios_base::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(TreeNode* t, <span class="keyword">int</span>&amp; Ans)</span> </span>&#123; <span class="comment">//maxPathSum through t</span></span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = go(t-&gt;left, Ans), R = go(t-&gt;right, Ans), Ret = <span class="number">0</span>;</span><br><span class="line">        Ret = max(t-&gt;val, t-&gt;val + max(L, R));</span><br><span class="line">        Ans = max(Ans, max(L + R + t-&gt;val, Ret));</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Ans = INT_MIN;</span><br><span class="line">        go(t, Ans);</span><br><span class="line">        <span class="keyword">return</span> Ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Maximum-Path-Sum&quot;&gt;&lt;a href=&quot;#Binary-Tree-Maximum-Path-Sum&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Maximum Path Sum&quot;&gt;&lt;/a&gt;Bi
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 145. Binary Tree Postorder Traversal</title>
    <link href="http://ziquanzhang.ink/2018/09/23/LeetCode-145-Binary-Tree-Postorder-Traversal/"/>
    <id>http://ziquanzhang.ink/2018/09/23/LeetCode-145-Binary-Tree-Postorder-Traversal/</id>
    <published>2018-09-23T02:10:00.000Z</published>
    <updated>2018-09-30T02:14:21.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Tree-Postorder-Traversal"><a href="#Binary-Tree-Postorder-Traversal" class="headerlink" title="Binary Tree Postorder Traversal"></a>Binary Tree Postorder Traversal</h1><p>week3</p><p>难度：Hard</p><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p><strong>Example:</strong></p><pre>    Input: [1,null,2,3]    1        \        2        /    3    Output: [3,2,1]</pre><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题目就是普通的后序遍历，即访问一棵树对其子节点使用左，右，中的顺序进行访问，其中有递归和遍历的做法。</p><ol><li><p>递归思路：<br> 递归的做法就是采用分而治之的方法，对一棵树均划分成3个节点，每当到一个节点时，先对其左节点递归，再到右节点，最后插入中节点后结束递归，以及当所到节点为空时也结束递归。</p></li><li><p>遍历思路：<br> 遍历的思路就是使用一个栈来存取遍历的节点，当访问完其中所有的子节点时，再使它出栈，其中也是用了递归的思路，因为递归就是通过栈来实现的。</p></li></ol><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>递归思路</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; leftans = postorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; rightans = postorderTraversal(root-&gt;right);</span><br><span class="line">        ans.insert(ans.end(),leftans.begin(),leftans.end());</span><br><span class="line">        ans.insert(ans.end(),rightans.begin(),rightans.end());</span><br><span class="line">        ans.insert(ans.end(),root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>遍历思路</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode* pre = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            TreeNode* p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.insert(res.begin(), p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) s.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>按照时间复杂度来算遍历的应该比递归的要快，但在网页上显示是一样的速度，看了一下比较慢的就是一些人先是用了栈来处理节点，到最后访问子节点的时候又用回递归的方法了，这种是典型的没有理解好stack的用法，其先进后出的性质可以让子节点也使用stack来进行遍历。</p><p>此外还有一种做法就是使用先序遍历后，再进行翻转从而得到后序遍历的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">stack</span>.push(root);</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">    TreeNode* cur = <span class="built_in">stack</span>.top();</span><br><span class="line">    <span class="built_in">stack</span>.pop();</span><br><span class="line">    res.push_back(cur-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(res.begin(),res.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Tree-Postorder-Traversal&quot;&gt;&lt;a href=&quot;#Binary-Tree-Postorder-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree Postorder Traversa
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode] 765. Couples Holding Hands</title>
    <link href="http://ziquanzhang.ink/2018/09/15/LeetCode/"/>
    <id>http://ziquanzhang.ink/2018/09/15/LeetCode/</id>
    <published>2018-09-15T09:11:00.000Z</published>
    <updated>2018-09-15T09:14:56.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Couples-Holding-Hands"><a href="#Couples-Holding-Hands" class="headerlink" title="Couples Holding Hands"></a>Couples Holding Hands</h1><p>week 2</p><p><a href="https://leetcode.com/problems/couples-holding-hands/description/&quot;" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p><p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p><p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p><p><strong>Example 1:</strong></p><pre>Input: row = [0, 2, 1, 3]Output: 1Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</pre><p><strong>Example 2:</strong></p><pre>Input: row = [3, 2, 0, 1]Output: 0Explanation: All couples are already seated side by side.</pre><p><strong>Note:</strong> <ol><li>len(row) is even and in the range of [4, 60].</li><li>row is guaranteed to be a permutation of 0...len(row)-1.</li></ol></p><hr><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个题意为有N对情侣坐在2N个座位上，但是他们并不是坐在一起的，要使得每一对都能并肩坐在一起，计算最少的交换次数，一次交换可以选择任意的两个人。</p><p>情侣按照顺序编号，并不是相连的都是情侣，（0，1），（2，3）等等。由此可知一个偶数的下一个奇数必定是它的另一半。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里的交换有两种可能：</p><ol><li>交换一次后，有两组情侣完成配对。</li><li>交换一次后，仅有一组情侣完成配对，而另一个等待继续交换。</li></ol><p>可知如果每一次都是第一种交换的话，则交换次数会比第二种要少，第一种为最佳交换，因此怎么样才能让其先完成第一种匹配呢，我的想法是，既然是第一种，则他们的情侣是交叉坐的，因此若这4个人中有2组情侣，则其和其他组的情侣就没有交集，所以无论如何其它组的情侣如何交换都不会影响到他们。（这里指交换都要匹配成功，如果试图以一次不成功的匹配凑出第一种情况，那么要匹配成功还要交换一次，那么使用第二种也是2次，在次数上是没有任何不同的）</p><p>所以我们可以采用贪心算法，遍历每一组，当它的旁边不是它的情侣时，就向后遍历寻找其情侣，进行交换然后匹配成功，这里因为我们发现他们的id的特殊性，可以判断奇偶，快速找到其另一半。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); i +=<span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cp;</span><br><span class="line">            <span class="keyword">if</span> (row[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cp = row[i] + <span class="number">1</span>;<span class="comment">//若为偶数则情侣为下一个奇数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cp = row[i] - <span class="number">1</span>;<span class="comment">//若为奇数则情侣为上一个偶数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (row[i + <span class="number">1</span>] == cp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j&lt; row.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[j] == cp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = row[i+<span class="number">1</span>];</span><br><span class="line">                    row[i+<span class="number">1</span>] = row[j];</span><br><span class="line">                    row[j] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当做到这道题目的时候，便想使用贪心算法，但一直都想不清楚如何去证明，后来发现其实他们的交换先后是无关的。<br>根据网上严谨的证明应该是把row抽象成为一个n个顶点的无向图，每个顶点中为两个人，两个顶点存在边时当且仅当两个顶点中能构成一对情侣，若是第一种情况，则构成重边。<br>相连的顶点构成圈，圈里面的若为第二种情况，所以对每一个圈来说有n个顶点就至少需要n-1次交换，若为第一种情况，即有重边，只需一次交换，也是n-1（两个顶点，2-1）。<br>因此若row有n组，m个圈，则至少需要n-m次。这和以上的结论是一样的，因为不同圈之间并不会发生交换。</p><hr><h2 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h2><p>使用哈希配对的方法，两个数均除以2，若相等，则为同一组，若否，则区分出较大和较小的数，若两个数存在联系，则返回，若不存在，则建立这两个数的联系。最后根据哈希表中联系的个数来得到最小交换次数，原理同上面的一样，这里的联系就是指的是顶点之间的边，每个边需要一次交换，重边算作一次，所以每次要判断两个数是否存在联系。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            helper(m, row[i] / <span class="number">2</span>, row[i + <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; m, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = min(x, y), c2 = max(x, y);</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(c1)) helper(m, m[c1], c2);</span><br><span class="line">        <span class="keyword">else</span> m[c1] = c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Couples-Holding-Hands&quot;&gt;&lt;a href=&quot;#Couples-Holding-Hands&quot; class=&quot;headerlink&quot; title=&quot;Couples Holding Hands&quot;&gt;&lt;/a&gt;Couples Holding Hands&lt;/
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数值计算实验一</title>
    <link href="http://ziquanzhang.ink/2018/09/12/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <id>http://ziquanzhang.ink/2018/09/12/数值计算实验一/</id>
    <published>2018-09-12T11:46:27.000Z</published>
    <updated>2018-09-12T14:01:52.013Z</updated>
    
    <content type="html"><![CDATA[<p><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..."></script></p><h1 id="数值计算实验"><a href="#数值计算实验" class="headerlink" title="数值计算实验"></a>数值计算实验</h1><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>求解线性方程组 Ax=b，其中 A 为 nⅹn 维的已知矩阵，b 为 n 维的已知向量，x 为 n 维的未知向量。</p><p>A 与 b 中的元素服从独立同分布的正态分布。令 n=10、50、100、200，测试计算时间并绘制曲线。 </p><p>（1）高斯消去法。</p><p>（2）列主元消去法。</p><h3 id="2-算法设计"><a href="#2-算法设计" class="headerlink" title="2.算法设计"></a>2.算法设计</h3><h4 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h4><p>（1）消元：使用逐次消去未知数的方法把原线性方程组Ax = b化为与其等价的三角形线性方程组。</p><p>在这里使用将方程乘以某一乘数加到其它方程上以进行消元，乘数为两个未知数之商。得到等价的三角形线性方程组。</p><p>（2）回代：求解上三角线性方程组利用回代的方法，从下至上求出方程组中的一方程的未知数，然后逐层回代求出其它方程的未知数。</p><h4 id="列主元消去法"><a href="#列主元消去法" class="headerlink" title="列主元消去法"></a>列主元消去法</h4><p>与高斯消去法类似，在消元阶段进行交换行，选取绝对值最大的元素作为主元素，避免主元素为0，无法进行消元，以及当主元素很小时，作除数导致数值不稳定产生较大的误差。</p><p>回代方法和高斯消去法一致。</p><h3 id="3-数值实验"><a href="#3-数值实验" class="headerlink" title="3.数值实验"></a>3.数值实验</h3><p>随机构造出多个矩阵以及多个向量，矩阵和向量的维数n分别为10、50、100、200，同时使用高斯消去法，列主元消去法进行线性方程组的求解，比较两种算法的计算时间以及其计算时间与矩阵的维数（大小）的关系。</p><p>实验结果一：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test1.png" alt="test1" title="">                </div>                <div class="image-caption">test1</div>            </figure></p><p>实验结果二：    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test1-1.png" alt="test1-1" title="">                </div>                <div class="image-caption">test1-1</div>            </figure></p><p>​    </p><p>进行拟合：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/拟合.png" alt="拟合" title="">                </div>                <div class="image-caption">拟合</div>            </figure></p><h3 id="4-结果分析"><a href="#4-结果分析" class="headerlink" title="4.结果分析"></a>4.结果分析</h3><p>通过进行计算时间的测试，并绘制曲线得到实验结果，观察可得列主元消去法因为要进行查找绝对值最大主元素，并进行交换使得计算时间比普通高斯消去方法稍长，但两者的计算时间还是相近。</p><p>另外当矩阵的维数（大小）变大，这种消元回代方法的计算时间也大幅度增长，通过函数的拟合发现其计算时间为O（n^3）的，n为矩阵的维数。</p><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>求解线性方程组 Ax=b，其中 A 为 nⅹn 维的已知矩阵，b 为 n 维的已知向量，x 为 n 维的未知向量。</p><p>A 为对称正定矩阵，其特征值服从独立同分布的[0,1]间的均匀分布；b 中的元素服从独立同分布的正态分布。 </p><p>令 n=10、50、100、200，分别绘制出算法的收敛曲线，横坐标为迭代步数，纵坐标为相对误差。比较Jacobi 迭代法、Gauss-Seidel 迭代法、逐次超松弛迭代法、共轭梯度法与高斯消去法、列主元消去法的计算时间。改变逐次超松弛迭代法的松弛因子，分析其对收敛速度的影响。 </p><h3 id="2-算法设计-1"><a href="#2-算法设计-1" class="headerlink" title="2.算法设计"></a>2.算法设计</h3><h4 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h4><p>雅可比迭代法的思想在于把当前的x初始量当成方程组的解，从而进行回代得出下一步x的近似解，这种方法每次迭代都使用上一次迭代的x，若迭代矩阵谱半径&lt;1，则在一定迭代次数后，x会收敛成精确解。</p><h4 id="Gauss-Seidel-迭代法"><a href="#Gauss-Seidel-迭代法" class="headerlink" title="Gauss-Seidel 迭代法"></a>Gauss-Seidel 迭代法</h4><p>高斯-赛德尔迭代与雅可比迭代类似，但是在每次迭代之中使用变量的最新信息计算x(k+1)，是雅可比迭代法的改进。</p><h4 id="逐次超松弛迭代法"><a href="#逐次超松弛迭代法" class="headerlink" title="逐次超松弛迭代法"></a>逐次超松弛迭代法</h4><p>逐次超松弛迭代是高斯-赛德尔迭代的一种修正，当w 为1 时即为高斯-赛德尔迭代，即在每一步的迭代后，对上一步的\(x^(k)\)和迭代后的x‘进行加权运算 $x(k+1) = (1-w)<em>x(k)+ w</em>x(k)$，超松弛迭代w&gt;1，一般为1&lt;w&lt;2，相当于做外插，加快收敛速度。</p><h4 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h4><p>将解线性方程组转化成求解一个等价的二次函数\(f(x) = 1/2<em> x^T </em> A <em>x - b^T </em>x\)极小化的问题，从任意起始点出发沿A的共轭方向进行线性搜索得到二次函数的极小点。</p><h3 id="3-数值实验-1"><a href="#3-数值实验-1" class="headerlink" title="3.数值实验"></a>3.数值实验</h3><h4 id="四种迭代法的收敛"><a href="#四种迭代法的收敛" class="headerlink" title="四种迭代法的收敛"></a>四种迭代法的收敛</h4><p>n = 10的收敛曲线：（SOR收敛因子w 为1.1）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-1.png" alt="test2-1" title="">                </div>                <div class="image-caption">test2-1</div>            </figure></p><p>n = 50的收敛曲线：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-2.png" alt="test2-2" title="">                </div>                <div class="image-caption">test2-2</div>            </figure></p><p>n = 100的收敛曲线：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-3.png" alt="test2-3" title="">                </div>                <div class="image-caption">test2-3</div>            </figure></p><p>n = 200的收敛曲线：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-4.png" alt="test2-4" title="">                </div>                <div class="image-caption">test2-4</div>            </figure></p><h4 id="六种算法计算时间的比较"><a href="#六种算法计算时间的比较" class="headerlink" title="六种算法计算时间的比较"></a>六种算法计算时间的比较</h4><p>n = 10：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-5.png" alt="test2-5" title="">                </div>                <div class="image-caption">test2-5</div>            </figure></p><p>n = 50：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-6.png" alt="test2-6" title="">                </div>                <div class="image-caption">test2-6</div>            </figure></p><p>n = 100：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-7.png" alt="test2-7" title="">                </div>                <div class="image-caption">test2-7</div>            </figure></p><p>n = 200：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test2-8.png" alt="test2-8" title="">                </div>                <div class="image-caption">test2-8</div>            </figure></p><h4 id="逐次超松弛迭代松弛因子（w）的影响"><a href="#逐次超松弛迭代松弛因子（w）的影响" class="headerlink" title="逐次超松弛迭代松弛因子（w）的影响"></a>逐次超松弛迭代松弛因子（w）的影响</h4><p>完整的图：（此时n =200）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test3.png" alt="test3" title="">                </div>                <div class="image-caption">test3</div>            </figure></p><p>Y：（0，0.5）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/09/12/数值计算实验一/test3-1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="4-结果分析-1"><a href="#4-结果分析-1" class="headerlink" title="4.结果分析"></a>4.结果分析</h3><ol><li>根据实验二的结果可得在四种迭代法中，雅可比迭代法收敛性较差，据其改进的高斯-赛德尔则较好，而增加了加权平均进行外插运算的逐次超松弛迭代收敛速度更快，收敛速度最快的则是共轭梯度法。</li><li>而六种算法的计算时间中可以看出，当矩阵较小时，迭代法和消元法计算时间相差不大，矩阵较大时，共轭梯度法在计算时间中有着较大的优势，达到所需精度的迭代次数比其它迭代次数要少很多，并且每次迭代耗时较少。因为构造的矩阵并不是稀疏矩阵，所以在这种情况下，普通的消元法比其它迭代法所耗时间要少。</li><li>在分析松弛因子对收敛速度影响中，松弛因子对算法的收敛速度影响很大，选择合适的松弛因子能够减少算法的迭代次数，在较少的迭代次数得到较为精确的结果，对于不同的矩阵有着不同的最佳松弛因子，对于本次模拟的矩阵w较大则最好，但是w超过2之后，算法则不再收敛。</li></ol><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><h3 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>在 <a href="https://snap.stanford.edu/data/soc-Epinions1.html" target="_blank" rel="noopener">Epinions 社交数据集</a>中，每个网络节点可以选择信任其它节点。借鉴 Pagerank 的思想编写程序，对网络节点的受信任程度进行评分。在实验报告中，请给出伪代码。 </p><h3 id="2-算法设计-2"><a href="#2-算法设计-2" class="headerlink" title="2.算法设计"></a>2.算法设计</h3><p>和pagerank相类似，预先给每个网络节点一个信任值Trust值为1/N，N为节点的数量，这样就能得到一个向量v代表每个节点的信任评分rank</p><script type="math/tex; mode=display">v = [1/n,1/n,1/n,……]</script><p>假定每个节点的对其他节点的总的信任程度为1，而且对每个其信任的节点都给予相同的信任程度，这样就可以得到一个信任转移矩阵A。</p><script type="math/tex; mode=display">A（i，j）= 节点i对节点j的信任程度</script><p>每个节点的信任评分rank由信任它的节点决定，如果信任评分的节点本身的信任评分高，则给予的评分权重也高，反之给予评分权重较低。</p><p>所以通过计算</p><script type="math/tex; mode=display">v‘ = Mv</script><p>即</p><script type="math/tex; mode=display">v(i) = ∑其它节点信任评分v(j)*信任程度A(i,j)</script><p>可以得到新的一个信任评分，经过有限次的迭代，v’将会收敛稳定下来，得到的即是各个节点的信任评分。</p><p><strong>改进</strong></p><p>对于一些只信任自己的，对其它节点并未作出信任的网页节点，采用这种算法有2个缺点</p><p>1.使得信任评分都集中到那一循环的节点上。</p><p>2.对于新建立的网络节点来说，并不公平，因为一开始没有其他节点信任它，可能导致信任评分恶性循环。</p><p>因此添加一个权重占比α，原先的评分仅占α，然后默认每一个节点都对其它节点有一定程度（较小但不为0）的信任，这个信任程度影响评分所占的权重为1-α。因此迭代公式变为：</p><script type="math/tex; mode=display">v(i) = ∑v(j)*A(i,j)*α+(1-α)/N</script><p>α一般设定为0.85。</p><h3 id="3-伪代码"><a href="#3-伪代码" class="headerlink" title="3.伪代码"></a>3.伪代码</h3><pre><code>A = [N,N];α = 0.85;%设定权重%构建转移矩阵，即信任关系矩阵for i = 1: N    for j = 1 : N    A[i,j] = 1/n(n 为i的所有出链，即给予信任的节点数总数)    endend%初始化信任评分rankv0(1:N) = 1/N;v = v0%迭代while norm(v-v0,'inf')>0.01 %当v逐渐收敛后结束迭代    v0 = v;    for i = 1: N        sum = 0;        for j = 1 : N            %计算其它节点给予该节点的信任评分            sum = sum + A(j,i)*v0(j)*α + (1-α)/N        end        v(i) = sum;    endenddisp(v');</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?...&quot;&gt;
&lt;/script&gt;&lt;/p&gt;
&lt;h1 id=&quot;数值计
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[LeetCode] 75. Sort Colors</title>
    <link href="http://ziquanzhang.ink/2018/09/09/Leetcode-75-Sort-Colors/"/>
    <id>http://ziquanzhang.ink/2018/09/09/Leetcode-75-Sort-Colors/</id>
    <published>2018-09-09T02:46:00.000Z</published>
    <updated>2018-09-15T09:17:36.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h1><p>week1</p><p><a href="https://leetcode.com/problems/sort-colors/description/&quot;" target="_blank" rel="noopener">题目链接</a></p><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given an array with n objects colored red, white or blue, sort them <a href="&quot;https://en.wikipedia.org/wiki/In-place_algorithm&quot;">in-place</a> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p><p><strong>Example:</strong></p><pre>Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]</pre><p><strong>Follow up:</strong></p><ul><li><p>A rather straight forward solution is a two-pass algorithm using counting sort.</p>First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.</li><li>Could you come up with a one-pass algorithm using only constant space?</li></ul><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题主要是对已知数的排序，数组中的每一个数的范围都已确定，因此用以往的排序如快排，归并排序并不合适，要做到一次遍历完成并使用常空间，所以我选择使用插排来完成。</p><p>先使用普通的插排发现时间会很慢，而在这个过程中发现一般的插排都是逐个比较的，而这道题目的特殊点在于数的种类较少只有3个，而且是已知的，那么我们可以记录下每个数应插到的位置，就节省了比较的过程。</p><p>记录下0，1，2的可插入点的前一位，比如插入1后，1可插点向后移，而2因为只能在1后，所以也向后移，而0不受1影响，插入点不变。最重要的一点是当插入0/1时，会替换掉原本的数，因为后面的数向后移动，可以当作(1，2)/2也插入到数组中（后移替换掉原本的数）。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> red = <span class="number">-1</span>, white = <span class="number">-1</span>, blue = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                red++;</span><br><span class="line">                white++;</span><br><span class="line">                blue++;</span><br><span class="line">                nums[blue] = <span class="number">2</span>;</span><br><span class="line">                nums[white] = <span class="number">1</span>;</span><br><span class="line">                nums[red] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                white++;</span><br><span class="line">                blue++;</span><br><span class="line">                nums[blue] = <span class="number">2</span>;</span><br><span class="line">                nums[white] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                blue++;</span><br><span class="line">                nums[blue] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>值得注意的是我们在写的时候，要把要插入的步骤写在其它数做完后移操作之后，因为存在一种可能假设现在整个数组中还不存在1，当你要插入0时，此时0和1的插入点是相同的，假设你先插入再后移，会使得插入的0被1替换掉（因为我们的后移操作是假设1的插入点前是1，0的插入点前是0），反之1被0替换则正确。</p><p>这种算法适合于已知数且不同数较少的排序，用替换取代后移，节省时间和空间。<br>时间复杂度和空间复杂度均为常数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sort-Colors&quot;&gt;&lt;a href=&quot;#Sort-Colors&quot; class=&quot;headerlink&quot; title=&quot;Sort Colors&quot;&gt;&lt;/a&gt;Sort Colors&lt;/h1&gt;&lt;p&gt;week1&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leet
      
    
    </summary>
    
      <category term="The Design and Analysis of Computer Algorithms" scheme="http://ziquanzhang.ink/categories/The-Design-and-Analysis-of-Computer-Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://ziquanzhang.ink/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://ziquanzhang.ink/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>I am a title</title>
    <link href="http://ziquanzhang.ink/2018/09/05/I-am-a-title-1/"/>
    <id>http://ziquanzhang.ink/2018/09/05/I-am-a-title-1/</id>
    <published>2018-09-05T07:59:00.000Z</published>
    <updated>2018-09-12T13:30:11.459Z</updated>
    
    <content type="html"><![CDATA[<p><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..."></script></p><h1 id="Welcome-to-StackEdit"><a href="#Welcome-to-StackEdit" class="headerlink" title="Welcome to StackEdit!"></a>Welcome to StackEdit!</h1><p>Hi! I’m your first Markdown file in <strong>StackEdit</strong>. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the <strong>file explorer</strong> on the left corner of the navigation bar.</p><h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><p>StackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible <strong>offline!</strong></p><h2 id="Create-files-and-folders"><a href="#Create-files-and-folders" class="headerlink" title="Create files and folders"></a>Create files and folders</h2><p>The file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the <strong>New file</strong> button in the file explorer. You can also create folders by clicking the <strong>New folder</strong> button.</p><h2 id="Switch-to-another-file"><a href="#Switch-to-another-file" class="headerlink" title="Switch to another file"></a>Switch to another file</h2><p>All your files are listed in the file explorer. You can switch from one to another by clicking a file in the list.</p><h2 id="Rename-a-file"><a href="#Rename-a-file" class="headerlink" title="Rename a file"></a>Rename a file</h2><p>You can rename the current file by clicking the file name in the navigation bar or by clicking the <strong>Rename</strong> button in the file explorer.</p><h2 id="Delete-a-file"><a href="#Delete-a-file" class="headerlink" title="Delete a file"></a>Delete a file</h2><p>You can delete the current file by clicking the <strong>Remove</strong> button in the file explorer. The file will be moved into the <strong>Trash</strong> folder and automatically deleted after 7 days of inactivity.</p><h2 id="Export-a-file"><a href="#Export-a-file" class="headerlink" title="Export a file"></a>Export a file</h2><p>You can export the current file by clicking <strong>Export to disk</strong> in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.</p><h1 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h1><p>Synchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your <strong>Google Drive</strong>, your <strong>Dropbox</strong> and your <strong>GitHub</strong> accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow… The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.</p><p>There are two types of synchronization and they can complement each other:</p><ul><li><p>The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device.</p><blockquote><p>To start syncing your workspace, just sign in with Google in the menu.</p></blockquote></li><li><p>The file synchronization will keep one file of the workspace synced with one or multiple files in <strong>Google Drive</strong>, <strong>Dropbox</strong> or <strong>GitHub</strong>.</p><blockquote><p>Before starting to sync files, you must link an account in the <strong>Synchronize</strong> sub-menu.</p></blockquote></li></ul><h2 id="Open-a-file"><a href="#Open-a-file" class="headerlink" title="Open a file"></a>Open a file</h2><p>You can open a file from <strong>Google Drive</strong>, <strong>Dropbox</strong> or <strong>GitHub</strong> by opening the <strong>Synchronize</strong> sub-menu and clicking <strong>Open from</strong>. Once opened in the workspace, any modification in the file will be automatically synced.</p><h2 id="Save-a-file"><a href="#Save-a-file" class="headerlink" title="Save a file"></a>Save a file</h2><p>You can save any file of the workspace to <strong>Google Drive</strong>, <strong>Dropbox</strong> or <strong>GitHub</strong> by opening the <strong>Synchronize</strong> sub-menu and clicking <strong>Save on</strong>. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.</p><h2 id="Synchronize-a-file"><a href="#Synchronize-a-file" class="headerlink" title="Synchronize a file"></a>Synchronize a file</h2><p>Once your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.</p><p>If you just have modified your file and you want to force syncing, click the <strong>Synchronize now</strong> button in the navigation bar.</p><blockquote><p><strong>Note:</strong> The <strong>Synchronize now</strong> button is disabled if you have no file to synchronize.</p></blockquote><h2 id="Manage-file-synchronization"><a href="#Manage-file-synchronization" class="headerlink" title="Manage file synchronization"></a>Manage file synchronization</h2><p>Since one file can be synced with multiple locations, you can list and manage synchronized locations by clicking <strong>File synchronization</strong> in the <strong>Synchronize</strong> sub-menu. This allows you to list and remove synchronized locations that are linked to your file.</p><h1 id="Publication"><a href="#Publication" class="headerlink" title="Publication"></a>Publication</h1><p>Publishing in StackEdit makes it simple for you to publish online your files. Once you’re happy with a file, you can publish it to different hosting platforms like <strong>Blogger</strong>, <strong>Dropbox</strong>, <strong>Gist</strong>, <strong>GitHub</strong>, <strong>Google Drive</strong>, <strong>WordPress</strong> and <strong>Zendesk</strong>. With <a href="http://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars templates</a>, you have full control over what you export.</p><blockquote><p>Before starting to publish, you must link an account in the <strong>Publish</strong> sub-menu.</p></blockquote><h2 id="Publish-a-File"><a href="#Publish-a-File" class="headerlink" title="Publish a File"></a>Publish a File</h2><p>You can publish your file by opening the <strong>Publish</strong> sub-menu and by clicking <strong>Publish to</strong>. For some locations, you can choose between the following formats:</p><ul><li>Markdown: publish the Markdown text on a website that can interpret it (<strong>GitHub</strong> for instance),</li><li>HTML: publish the file converted to HTML via a Handlebars template (on a blog for example).</li></ul><h2 id="Update-a-publication"><a href="#Update-a-publication" class="headerlink" title="Update a publication"></a>Update a publication</h2><p>After publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the <strong>Publish now</strong> button in the navigation bar.</p><blockquote><p><strong>Note:</strong> The <strong>Publish now</strong> button is disabled if your file has not been published yet.</p></blockquote><h2 id="Manage-file-publication"><a href="#Manage-file-publication" class="headerlink" title="Manage file publication"></a>Manage file publication</h2><p>Since one file can be published to multiple locations, you can list and manage publish locations by clicking <strong>File publication</strong> in the <strong>Publish</strong> sub-menu. This allows you to list and remove publication locations that are linked to your file.</p><h1 id="Markdown-extensions"><a href="#Markdown-extensions" class="headerlink" title="Markdown extensions"></a>Markdown extensions</h1><p>StackEdit extends the standard Markdown syntax by adding extra <strong>Markdown extensions</strong>, providing you with some nice features.</p><blockquote><p><strong>ProTip:</strong> You can disable any <strong>Markdown extension</strong> in the <strong>File properties</strong> dialog.</p></blockquote><h2 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h2><p>SmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example:</p><div class="table-container"><table><thead><tr><th></th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>— is en-dash, —- is em-dash</td></tr></tbody></table></div><h2 id="KaTeX"><a href="#KaTeX" class="headerlink" title="KaTeX"></a>KaTeX</h2><p>You can render LaTeX mathematical expressions using <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p><script type="math/tex; mode=display">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.</script><blockquote><p>You can find more information about <strong>LaTeX</strong> mathematical expressions <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="UML-diagrams"><a href="#UML-diagrams" class="headerlink" title="UML diagrams"></a>UML diagrams</h2><p>You can render UML diagrams using <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. For example, this will produce a sequence diagram:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Alice -&gt;&gt; Bob: Hello Bob, how are you?</span><br><span class="line">Bob--&gt;&gt;John: How about you John?</span><br><span class="line">Bob--x Alice: I am good thanks!</span><br><span class="line">Bob-x John: I am good thanks!</span><br><span class="line">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.</span><br><span class="line"></span><br><span class="line">Bob--&gt;Alice: Checking with John...</span><br><span class="line">Alice-&gt;John: Yes... John, how are you?</span><br></pre></td></tr></table></figure><p>And this will produce a flow chart:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Square Rect] -- Link text --&gt; B((Circle))</span><br><span class="line">A --&gt; C(Round Rect)</span><br><span class="line">B --&gt; D&#123;Rhombus&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?...&quot;&gt;
&lt;/script&gt;&lt;/p&gt;
&lt;h1 id=&quot;Wel
      
    
    </summary>
    
    
      <category term="test" scheme="http://ziquanzhang.ink/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ziquanzhang.ink/2018/09/04/hello-world/"/>
    <id>http://ziquanzhang.ink/2018/09/04/hello-world/</id>
    <published>2018-09-04T10:58:54.147Z</published>
    <updated>2018-09-04T10:58:54.147Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
