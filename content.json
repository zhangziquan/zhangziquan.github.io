[{"title":"[LeetCode] 732. My Calendar III","date":"2018-12-06T13:01:00.000Z","path":"2018/12/06/LeetCode-732-My-Calendar-III/","text":"732. My Calendar III week13 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Implement a MyCalendarThree class to store your events. A new event can always be added. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.) For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar. Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end) Example1: MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation: The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked. Note: The number of calls to MyCalendarThree.book per test case will be at most 400. In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9]. é¢˜ç›®åˆ†æ é¢˜ç›®ç®€å•æ¥è¯´ï¼Œå°±æ˜¯å¯»æ‰¾æœ€å¤§çš„é‡åˆæ•°é‡ï¼Œå¯ä»¥çœ‹ä½œä¸ºæœ‰è®¸å¤šæ¡çº¿æ®µåœ¨ä¸€ä¸ªåŒºé—´ä¸Šï¼Œæ¯åŠ å…¥ä¸€æ¡çº¿æ®µåˆ™è¦å¾—å‡ºæœ€å¤§çš„é‡å æ•°é‡ï¼Œé‡å å°±æ˜¯æŒ‡çº¿æ®µæœ‰ä¸€æ®µé‡åˆçš„åŒºé—´åˆ™è¿™ä¸¤æ¡çº¿æ®µé‡å ã€‚ è§£é¢˜æ€è·¯ è¿™é“é¢˜æˆ‘æƒ³çš„æ˜¯å¦‚æœè¦æ±‚æœ€å¤§é‡å æ•°é‡ï¼Œå‡å¦‚å¯¹æ¯æ¡çº¿æ®µéƒ½å»éå†ä¸€éå¾—å‡ºé‡åˆçš„çº¿æ®µå†ç»Ÿè®¡çš„è¯å°±å¾ˆéº»çƒ¦ï¼Œå³ä½¿ç»´æŠ¤ä¸€ä¸ªæœ€å¤§æ•°é‡æ¯æ¬¡æ’å…¥åæ¯”è¾ƒï¼Œä¹Ÿå¹¶ä¸ä¼šå¾ˆå¥½åšã€‚ å¯¹äºè¿™ä¸ªé¢˜ç›®å¯ä»¥æƒ³åˆ°è¿™ä¹ˆä¸€ç§åšæ³•ï¼Œè®°å½•ä¸‹æ¯ä¸€æ¡çº¿æ®µçš„èµ·ç‚¹ä¸ç»ˆç‚¹ï¼Œç„¶ååœ¨è¿™ä¸€ä¸ªåŒºé—´ä¸Šéå†ï¼Œå¦‚æœé‡åˆ°èµ·ç‚¹ï¼Œé‚£ä¹ˆæ­¤æ—¶æœ‰ä¸€æ¡çº¿æ®µåŠ å…¥ï¼Œå¦‚æœé‡åˆ°ç»ˆç‚¹ï¼Œå³æ„å‘³ç€æœ‰ä¸€æ¡çº¿æ®µç»“æŸäº†ï¼Œé€šè¿‡è¿™ç§åšæ³•å¯ä»¥å¾—å‡ºåœ¨æŸä¸ªç‚¹ä¸Šçº¿æ®µæœ‰å¤šå°‘æ¡ï¼Œæ±‚å‡ºæœ€å¤§çš„å³å¯ã€‚ åœ¨æ•°æ®ç»“æ„ä¸Šé€‰æ‹©mapå¯ä»¥ä¸ç”¨è€ƒè™‘æ’åºçš„é—®é¢˜ï¼Œè€Œä¸”é”®å€¼å¯¹ä¾¿äºä¿®æ”¹ã€‚åŠ å…¥çº¿æ®µï¼Œçº¿æ®µçš„èµ·ç‚¹æ•°å€¼+1ï¼Œç»ˆç‚¹-1ï¼Œè¿™æ ·åœ¨éå†è¿™æ•´ä¸ªåŒºé—´æ—¶ï¼Œç›´æ¥åŠ ä¸Šè¯¥ç‚¹çš„æ•°å€¼å³å¯æ–¹ä¾¿ç»Ÿè®¡çº¿æ®µæ•°é‡ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930class MyCalendarThree&#123; public: map&lt;int, int&gt; m; int maximum; MyCalendarThree() &#123; maximum = 0; &#125; int book(int start, int end) &#123; int num = 0; m[start]++; m[end]--; for (auto i = m.begin(); i != m.end(); ++i) &#123; num += i-&gt;second; if (maximum &lt; num) maximum = num; &#125; return maximum; &#125;&#125;;/** * Your MyCalendarThree object will be instantiated and called as such: * MyCalendarThree obj = new MyCalendarThree(); * int param_1 = obj.book(start,end); */ ç»“æœåæ€ ![upload successful](\\images\\pasted-15.png) è¿™ä¸ªç®—æ³•è™½ç„¶è¿è¡Œé€Ÿåº¦ä¸å¿«ï¼Œä½†æ˜¯èƒœäºéå¸¸ç®€å•ã€‚ã€‚å¾ˆå®¹æ˜“ç†è§£ã€‚ä»£ç ä¹Ÿéå¸¸ç®€æ´ï¼Œå°±é‚£ä¹ˆå‡ è¡Œæå®šï¼Œä¸»è¦æ˜¯è¦é€‰æ‹©é€‚åˆçš„æ•°æ®ç»“æ„å­˜å‚¨ã€‚ æ€»ç»“ è¿™ä¸ªæ–¹æ³•å…¶å®æ˜¯æœ‰å‘å›¾çš„ä¸€ä¸ªå˜å½¢ï¼Œç”¨åˆ°äº†å‡ºåº¦å’Œå…¥åº¦çš„æ–¹æ³•ï¼Œå°±å’Œæˆ‘è¯´çš„åˆå§‹å’Œé—­åˆä¸€æ ·ï¼Œåˆ°åˆå§‹ç‚¹æ•°é‡++ï¼Œåˆ°äº†ç»ˆç‚¹æ•°é‡â€“ã€‚æ‰€ä»¥æœ€å¤§æ•°é‡æ€»æ˜¯åœ¨æŸä¸ªçº¿æ®µå¼€å§‹çš„åœ°æ–¹çš„ï¼Œå› æ­¤å°±è½¬å˜ä¸ºäº†å¯»æ‰¾æœ€å¤§çš„å‡ºåº¦ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"},{"name":"Graph","slug":"Graph","permalink":"http://ziquanzhang.ink/tags/Graph/"}]},{"title":"[LeetCode] 312. Burst Balloons","date":"2018-11-27T15:20:00.000Z","path":"2018/11/27/LeetCode-312-Burst-Balloons/","text":"312. Burst Balloons week12 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 â‰¤ n â‰¤ 500, 0 â‰¤ nums[i] â‰¤ 100 Example: Input: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 é¢˜ç›®åˆ†æ é¢˜æ„å°±æ˜¯ç»™äºˆä¸€è¿ä¸²çš„æ°”çƒï¼Œæ¯ä¸ªæ°”çƒä¸Šéƒ½æœ‰åˆ†æ•°ï¼Œå½“ç‚¹å‡»æ°”çƒåï¼Œæ°”çƒæ¶ˆå¤±ï¼Œè·å¾—çš„åˆ†æ•°å³æ˜¯è¢«ç‚¹å‡»çš„æ°”çƒ*ä¸¤è¾¹çš„æ°”çƒã€‚æ‰¾å‡ºå¯è·å¾—çš„æœ€å¤§åˆ†æ•°ã€‚ è§£é¢˜æ€è·¯ è¿™é“é¢˜æ˜ç¤ºä½¿ç”¨åŠ¨æ€è§„åˆ’ï¼Œè€ƒè™‘å°†é—®é¢˜åˆ†ä¸ºå¤šä¸ªå­é—®é¢˜è§£å†³ï¼Œå‡è®¾æŒ‰ç‚¹å‡»çš„é¡ºåºè®¡ç®—ï¼Œæ¯æ¬¡ç‚¹å‡»éƒ½ä¼šä½¿è¢«ç‚¹å‡»çš„æ°”çƒæ¶ˆå¤±ï¼Œå†æ ¹æ®å‰©ä¸‹çš„å…ƒç´ æ¥æ„é€ æ–°çš„æ•°ç»„ï¼Œé‚£ä¹ˆè¿™ä¸ªé—®é¢˜åˆå˜æˆäº†æ–°çš„ç¯å¢ƒï¼Œéš¾ä»¥ç®€å•åœ°å¤ç”¨è§£å†³ã€‚å‡è®¾æŒ‰å€’æ¨çš„æ–¹å¼æ€è€ƒï¼Œå‡è®¾æœ€åä¸€ä¸ªæ°”çƒè¢«æˆ³ç ´ï¼Œé‚£ä¹ˆå®ƒå·¦è¾¹æˆ–è€…å³è¾¹çš„æ°”çƒä¸ä¼šå—åˆ°å¯¹æ–¹çš„å½±å“ï¼Œå› ä¸ºéš”ç€ä¸€ä¸ªæ°”çƒå§‹ç»ˆåœ¨å®ƒä»¬çš„ä¸­é—´ï¼Œæ‰€ä»¥å·¦è¾¹å’Œå³è¾¹çš„æ°”çƒæˆ³ç ´é¡ºåºå°±å¯ä»¥åˆ†å¼€è®¡ç®—ï¼ŒåŒ–ç®€æˆå¤šä¸ªå°é—®é¢˜ã€‚ å‡è®¾ç¬¬iä¸ªæ°”çƒä¸ºæœ€åæˆ³ç ´çš„æ°”çƒï¼Œmax[a][b]ä¸ºç¬¬aåˆ°ç¬¬bä¸ªæ°”çƒè·å¾—çš„æœ€å¤§åˆ†æ•°ï¼Œé‚£ä¹ˆé—®é¢˜çš„è§£å°±å˜ä¸ºï¼š$$maxCoins[0][n - 1] = maxCoins[0][i - 1] + maxCoins[i + 1][n - 1] + nums[left] * nums[i] * nums[right]$$ ä»£ç  123456789101112131415161718192021class Solution&#123;public: int maxCoins(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 2; i &lt; n; i++) &#123; for (int l = 0; l &lt; n - i; l++) &#123; int r = l + i; for (int j = l + 1; j &lt; r; j++) &#123; dp[l][r] = max(dp[l][r], dp[l][j] + dp[j][r] + nums[l] * nums[r] * nums[j]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125;; ç»“æœåæ€ æµ‹è¯• è¿™ä¸ªç®—æ³•è¿˜æ˜¯æ¯”è¾ƒç®€æ´çš„ï¼Œæ²¡æœ‰ä»€ä¹ˆå¤šä½™çš„ä¸œè¥¿ï¼Œå°±æ˜¯çº¯dpã€‚ ä»£ç åˆ†æ å› ä¸ºè¦è€ƒè™‘åˆ°æˆ³ç ´æ°”çƒæ—¶ï¼Œæœ‰è¾¹ç•Œçš„é—®é¢˜ï¼Œæ‰€ä»¥åœ¨ä¸¤è¾¹åŠ ä¸Šä¸¤ä¸ªæ— æ³•è¢«æˆ³ç ´çš„åˆ†æ•°ä¸º1çš„æ°”çƒï¼Œæ„æˆn+2çš„æ–°æ•°ç»„ï¼Œæœ€åçš„çŠ¶æ€è½¬ç§»ä¸ºï¼š$$Coins[left][right] = max(Coins[left][right], Coins[left][i] + Coins[i][right] + nums[left] * nums[right] * nums[i]);$$ æ€»ç»“ è¿™ä¸ªé¢˜ç›®è¯´æ˜äº†åŠ¨æ€è§„åˆ’æœ‰æ—¶å€™æŒ‰æ­£å‘æ¨å¯¼åˆ†è§£é—®é¢˜å¯èƒ½ä¼šåˆ†è§£ä¸äº†å¤šä¸ªè¾ƒå°çš„å­é—®é¢˜ï¼Œåœ¨è¿™ç§æ—¶å€™è¦å°è¯•é€†å‘æ€ç»´ï¼Œåè¿‡æ¥æ€è€ƒåˆ°è¾¾æœ€åçš„çŠ¶æ€æ—¶ï¼Œè¦ç»è¿‡å“ªäº›çŠ¶æ€ã€‚è¿™é“é¢˜æœ‰ç‚¹å’Œä¸Šä¸¤å‘¨é‚£é“Freedom Trailå³è¾å°„4æ—‹è½¬å­—ç¬¦ä¸²ä¸€æ ·ï¼Œéƒ½æ˜¯ä»æœ€åçš„çŠ¶æ€å¼€å§‹ï¼Œä»è€Œåˆ†è§£æˆå¤šä¸ªå­é—®é¢˜ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://ziquanzhang.ink/tags/Dynamic-Programming/"}]},{"title":"[LeetCode] 354. Russian Doll Envelopes","date":"2018-11-17T08:45:00.000Z","path":"2018/11/17/LeetCode-354-Russian-Doll-Envelopes/","text":"354. Russian Doll Envelopes week11 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example: Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]). é¢˜ç›®åˆ†æ å†æ¥ä¸€é“åŠ¨æ€è§„åˆ’çš„é¢˜ç›®ï¼Œæœ¬é¢˜æ˜¯ä¸€é“å˜å½¢çš„æœ€é•¿å­ä¸²é¢˜ç›®ï¼Œè®²çš„æ˜¯ä¿„ç½—æ–¯å¥—å¨ƒé‚£ç§æ’åºï¼ŒNä¸ªä¿¡å°ç»™å‡ºé«˜å’Œå®½ï¼Œè‹¥ä¸€ä¸ªä¿¡å°çš„é«˜å’Œå®½éƒ½å¤§äºå¦ä¸€ä¸ªä¿¡å°ï¼Œåˆ™å¯ä»¥è£…è¿›å»ï¼Œç›®æ ‡æ±‚æœ€é•¿çš„åºåˆ—ã€‚ è§£é¢˜æ€è·¯ è¿™æ˜¯ä¸€é“æ¯”è¾ƒå¸¸è§çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œè®°å½•æ¯ä¸€ä¸ªä¿¡å°çš„æœ€å¤§è£…è½½æ•°é‡ï¼Œè‹¥æœ‰ä¿¡å°èƒ½è£…è¿›è¯¥ä¿¡å°ï¼Œé‚£ä¹ˆæ¯”è¾ƒè£…è½½æ•°é‡ï¼Œç„¶åé€æ­¥æ‰¾åˆ°æœ€å¤§è£…è½½æ•°é‡çš„ä¿¡å°å³å¯ã€‚ å°†ä¿¡å°ä»å°åˆ°å¤§æ’åºï¼Œå®½åº¦ä»å°åˆ°å¤§ï¼Œå®½åº¦ç›¸åŒåˆ™é«˜åº¦ä»å°åˆ°å¤§ï¼Œå¯¹åé¢çš„ä¿¡å°éƒ½è¦éå†å‰é¢çš„ä¿¡å°ï¼Œçœ‹æ˜¯å¦èƒ½è£…è¿›å»ï¼Œç„¶åæ›´æ–°dpï¼Œæ¯æ¬¡éƒ½æ¯”è¾ƒä¸‹ä¿¡å°çš„æœ€å¤§è£…è½½é‡ã€‚ ä»£ç  123456789101112131415161718192021222324class Solution&#123; public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt; &amp;envelopes) &#123; vector&lt;int&gt; dp(envelopes.size(), 1); pair&lt;int, int&gt; temp; sort(envelopes.begin(), envelopes.end()); int maxnum = 0; for (int i = 0; i &lt; envelopes.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (envelopes[i].first &gt; envelopes[j].first &amp;&amp; envelopes[i].second &gt; envelopes[j].second) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; maxnum = max(maxnum, dp[i]); &#125; return maxnum; &#125;&#125;; ç»“æœåæ€ æµ‹è¯• ä»ç»“æœçœ‹æ¥è¿™ç§åšæ³•ç®—æ˜¯ä¸­è§„ä¸­çŸ©ï¼Œå°±æ˜¯ä¸æ–­åœ°å»éå†ï¼Œå¯¹ä¿¡å°çš„è£…è½½æ•°é‡è¿›è¡Œä¸æ–­æ›´æ–°ï¼Œæœ€åè¾¾åˆ°æ”¶æ•›ï¼Œå°±åƒBellman-Fordç®—æ³•ä¸€æ ·ä¸æ–­æ›´æ–°ï¼Œè€Œä¸”è¿™ä¸ªå¥½åƒæ›´åŠ æ…¢ã€‚ã€‚ ç›®å‰æœ€ä½³è§£æ³• 1234567891011121314151617181920212223242526bool cmp(const pair&lt;int, int&gt; &amp;p1, const pair&lt;int, int&gt; &amp;p2) &#123; if (p1.first &lt; p2.first) &#123; return true; &#125; else if (p1.first == p2.first) &#123; return p1.second &gt; p2.second; &#125; return false;&#125;bool cmp2(const pair&lt;int, int&gt; &amp;p1, const pair&lt;int, int&gt; &amp;p2) &#123; return p1.second &lt; p2.second;&#125;class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; vector&lt;pair&lt;int, int&gt;&gt; dp; sort(envelopes.begin(), envelopes.end(), cmp); for (const pair&lt;int, int&gt; &amp;p : envelopes) &#123; auto iter = lower_bound(dp.begin(), dp.end(), p, cmp2); if (iter == dp.end()) &#123; dp.push_back(p); &#125; else &#123; dp[iter - dp.begin()] = p; &#125; &#125; return dp.size(); &#125;&#125;; ä»£ç åˆ†æ ç¬¬äºŒç§è§£æ³•ï¼Œè¿™ä¸ªä¼¼ä¹æ˜¯ç°åœ¨æœ€å¤šä¸”å¾ˆå¿«çš„è§£æ³•ï¼Œå’Œæ±‚æœ€é•¿é€’å¢å­ä¸²çš„é•¿åº¦ç›¸ç±»ä¼¼ï¼Œè¿ç”¨äº†å…¶ä¸­çš„æ€æƒ³ï¼Œä¹Ÿå°±æ˜¯è´ªå¿ƒå’ŒäºŒåˆ†çš„æƒ³æ³•ï¼Œå…ˆå¯¹å®½åº¦ä»å°åˆ°å¤§è¿›è¡Œæ’åºï¼Œè¿™æ ·èƒ½ä¿è¯åé¢çš„ä¿¡å°èƒ½è£…è¿›å‰é¢çš„ä¿¡å°ï¼Œç„¶åå¯¹é«˜åº¦è¿›è¡Œæœ€é•¿é€’å¢å­ä¸²å¯»æ‰¾æœ€é•¿ï¼Œè¿™æ ·å°±èƒ½å¾—åˆ°æœ€é•¿ï¼Œä¹Ÿè®¸ä¼šå‡ºç°å®½åº¦ç›¸åŒçš„æƒ…å†µï¼Œä½†æ˜¯è¿™ä¹Ÿè¯´æ˜äº†æœ€é•¿é€’å¢å­ä¸²è¿™ä¸ªé—®é¢˜çš„æƒ³æ³•ï¼Œå¾—åˆ°çš„è§£å¹¶ä¸ä¼šæ˜¯æ­£ç¡®çš„è§£ï¼Œä½†æ˜¯é•¿åº¦æ˜¯ç›¸åŒçš„ï¼Œå¯¹è¾ƒå¤§çš„è¿›è¡Œç½®æ¢æˆå°çš„ä½¿å¾—å®ƒèƒ½å¤Ÿå¾—åˆ°æ›´å¤§çš„æ½œåŠ›å»é€’å¢ï¼Œè¿™å°±æ˜¯è´ªå¿ƒçš„ç­–ç•¥ï¼Œåœ¨è´ªå¿ƒçš„åŒæ—¶å¹¶æ²¡æœ‰æ”¹å˜å…¶ä¸­çš„é•¿åº¦ï¼Œå¾ˆç²¾å¦™ã€‚ã€‚ã€‚ æ€»ç»“ è¿™ä¸ªé¢˜ç›®è¯´æ˜äº†åŠ¨æ€è§„åˆ’æœ‰æ—¶å€™å¹¶ä¸ä¼šæ˜¯æœ€ç®€å•çš„ï¼Œä½†ä¹Ÿæ˜¯æ¯”è¾ƒå¿«çš„äº†ï¼ŒåŠ¨æ€è§„åˆ’èƒ½å¤Ÿé¿å…è®¸å¤šå°é—®é¢˜çš„é‡å¤æ±‚è§£ï¼Œåœ¨æ±‚å¾—å¯¹åº”çš„åºåˆ—æ¯”é€’å½’æœ‰å¾ˆå¤§çš„ä¼˜åŠ¿ï¼Œåœ¨ä¸€äº›é—®é¢˜å½’çº³è‹¥å­é—®é¢˜çš„è§„æ¨¡ä»å¾ˆå¤§ï¼Œé‚£ä¹ˆåŠ¨æ€è§„åˆ’æ¯”é€’å½’å¥½å¾ˆå¤šã€‚ç¬¬äºŒç§çš„è´ªå¿ƒäºŒåˆ†ç®—æ³•æ˜¯åœ¨é¢˜ç›®åªè¦æ±‚å¾—é•¿åº¦ï¼Œè¿™æ ·è´ªå¿ƒç®—æ³•å°±èƒ½æœ€é€Ÿå¾—åˆ°é•¿åº¦ï¼Œä½†æ˜¯å§‹ç»ˆå¾—ä¸åˆ°åºåˆ—ã€‚è¦å¾—åˆ°æŒ‡å®šåºåˆ—è¿˜æ˜¯éœ€è¦åŠ¨æ€è§„åˆ’ã€‚å¯ä»¥è¯´æ˜¯å¥—ç€dpçš„çš®ï¼Œå®åˆ™æ˜¯è´ªå¿ƒç­–ç•¥ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://ziquanzhang.ink/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"http://ziquanzhang.ink/tags/Greedy/"}]},{"title":"[LeetCode] 514. Freedom Trail","date":"2018-11-09T08:52:00.000Z","path":"2018/11/09/LeetCode-514-Freedom-Trail/","text":"514. Freedom Trail week10 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° In the video game Fallout 4, the quest â€œRoad to Freedomâ€ requires players to reach a metal dial called the â€œFreedom Trail Ringâ€, and use the dial to spell a specific keyword in order to open the door. Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword. Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]: You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ringâ€™s characters at the 12:00 direction, where this character must equal to the character key[i]. If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, youâ€™ve finished all the spelling. Example: example Input: ring = â€œgoddingâ€, key = â€œgdâ€ Output: 4 Explanation: For the first key character â€˜gâ€™, since it is already in place, we just need 1 step to spell this character. For the second key character â€˜dâ€™, we need to rotate the ring â€œgoddingâ€ anticlockwise by two steps to make it become â€œddinggoâ€. Also, we need 1 more step for spelling. So the final output is 4. Note: Length of both ring and key will be in range 1 to 100. There are only lowercase letters in both strings and might be some duplcate characters in both strings. Itâ€™s guaranteed that string key could always be spelled by rotating the string ring. é¢˜ç›®åˆ†æ é¢˜ç›®çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œå…¶å®å¾ˆç®€å•ï¼Œè¯´çš„æ˜¯è¾å°„4ä¸­çš„ä¸€ä¸ªå°æ¸¸æˆï¼Œå³é€šè¿‡æ—‹è½¬æŒ‰é’®å°†æŒ‡é’ˆæŒ‡å‘å¯¹åº”çš„å­—ç¬¦ä¸²ï¼Œä»è€Œæ ¹æ®keyæŒ‰é¡ºåºæ¥æŒ‰å‡ºæ‰€æœ‰çš„å­—æ¯ï¼Œè¿™ä¸ªæŒ‰é’®å¯ä»¥é¡ºæ—¶é’ˆæˆ–è€…é€†æ—¶é’ˆæ—‹è½¬ï¼Œè¦æ±‚ç®—å‡ºæ‹¼å‡ºkeyçš„æœ€å°‘æ­¥æ•°ï¼ˆæŒ‰ä¸‹æŒ‰é’®ä¹Ÿç®—ä¸€æ­¥ï¼‰ã€‚ è§£é¢˜æ€è·¯ å› ä¸ºæ—‹é’®å¯ä»¥å·¦æ—‹æˆ–è€…å³æ—‹ï¼Œæ‰€ä»¥æ¯ä¸€æ¬¡çš„æ—‹è½¬è¿‡åçš„æŒ‡é’ˆéƒ½æœ‰å¯èƒ½ä¸ä¸€æ ·ï¼Œå› ä¸ºæ—‹é’®ä¸Šçš„å­—æ¯æ˜¯å¯é‡å¤çš„ã€‚å¯ä»¥è¯´æ¯ä¸€æ¬¡çš„æœ€çŸ­è·¯å¾„éƒ½ä¸ä¸€æ ·ã€‚å› æ­¤æˆ‘ä»¬ä¸èƒ½ç®€å•çš„è®¤ä¸ºæ¯ä¸€æ¬¡éƒ½å–æœ€çŸ­è·¯å¾„å°±è¡Œäº†ï¼Œå› ä¸ºä¸Šä¸€æ¬¡çš„é€‰æ‹©ä¼šå½±å“ä¸‹ä¸€æ¬¡çš„è¿›è¡Œã€‚ è¿™æ ·çœ‹æ¥è¿™é“é¢˜ç›®æ˜æ˜¾å°±æ˜¯åŠ¨æ€è§„åˆ’ä¸­çš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä¸€ä¸‹æ¯ä¸ªçŠ¶æ€ä¸‹çš„æ­¥æ•°ï¼Œåˆ°è¾¾ä¸‹ä¸€ä¸ªçŠ¶æ€å–ä¸Šä¸€ä¸ªçŠ¶æ€+åˆ°è¾¾ä¸‹ä¸€ä¸ªçŠ¶æ€çš„æ­¥æ•°çš„æœ€å°å€¼ï¼Œç±»ä¼¼äºæœ€çŸ­è·¯å¾„çš„åšæ³•ã€‚å› ä¸ºçŸ¥é“ä¸€å¼€å§‹æŒ‡é’ˆå¿…å®šæ˜¯æŒ‡å‘12ç‚¹é’Ÿæ–¹å‘ï¼Œæ‰€ä»¥å¯ä»¥ä»åå¾€å‰æ¨ï¼Œf(i,j) = min(f(i,j),abs(j-k) + f(i+1,k)),æ±‚å¾—çš„f(0)å³æ˜¯æœ€å°çš„æ­¥æ•°ã€‚å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„æˆ–è€…äºŒç»´å‘é‡å³å¯ä¿å­˜å…¶çŠ¶æ€ï¼Œå…¶ä¸­iä¸ºå½“å‰å·²åŒ¹é…æ•°ï¼Œjä¸ºæŒ‡é’ˆçš„æ–¹å‘ï¼ˆæŒ‡å‘çš„ä½ç½®ï¼‰ã€‚ å› ä¸ºæ¯ä¸€æ¬¡éƒ½è¦æŒ‰ä¸€ä¸‹ç¡®è®¤ï¼Œæ‰€ä»¥ç›´æ¥åœ¨æœ€ååŠ ä¸Škeyçš„é•¿åº¦ã€‚å› ä¸ºkeyå’Œringé•¿åº¦ä¸å®šï¼Œå»ºè®®ä½¿ç”¨äºŒç»´å‘é‡ã€‚ ç¬¬ä¸€æ¬¡å°è¯•ä»£ç  1234567891011121314151617181920212223242526class Solution&#123; public: int findRotateSteps(string ring, string key) &#123; vector&lt;vector&lt;int&gt;&gt; steps(key.length() + 1, vector&lt;int&gt;(ring.length())); for (int i = key.length() - 1; i &gt;= 0; i--) &#123; char next = key[i]; for (int j = 0; j &lt; ring.length(); j++) &#123; steps[i][j] = INT_MAX; for (int k = 0; k &lt; ring.length(); k++) &#123; if (next == ring[k]) &#123; int dist = abs(j - k); int step = min(dist, (int)ring.length() - dist); steps[i][j] = min(steps[i][j], step + steps[i + 1][k]); &#125; &#125; &#125; &#125; return steps[0][0] + key.length(); &#125;&#125;; ç»“æœåæ€ ç¬¬ä¸€æ¬¡æµ‹è¯• ç»è¿‡æµ‹è¯•ä¹‹åï¼Œè¿™ç§æ–¹æ³•çš„ç¡®å¯è¡Œï¼Œä½†çœ‹äº†è¿è¡Œç»“æœå‘ç°è¿™ä¸ªç®—æ³•è¿è¡Œçš„å¹¶ä¸æ˜¯å¾ˆå¿«ï¼Œå½“ringå˜å¾—å¾ˆé•¿æ—¶ï¼ŒèŠ±è´¹äº†å¾ˆå¤šçš„æ—¶é—´ã€‚åœ¨é€æ­¥è°ƒè¯•ä¹‹åï¼Œä¸€ä¸ªä¸»è¦çš„é—®é¢˜å°±æ˜¯åœ¨å¾ˆå¤šä¸å¿…è¦çš„çŠ¶æ€ä¸‹è¿›è¡Œäº†è®¡ç®—ã€‚æ¯”å¦‚æœ‰äº›çŠ¶æ€å§‹ç»ˆä¸ä¼šè¾¾åˆ°çš„ï¼Œæ²¡æœ‰è®¡ç®—çš„å¿…è¦ï¼Œè€Œä¸”è¿™ä¸ªä¸‰é‡å¾ªç¯å°±æ³¨å®šäº†è¿è¡Œæ—¶é—´å¹¶ä¸ä¼šå¾ˆçŸ­ã€‚ æ€è€ƒäº†ä¸€ä¸‹å¹¶å‚è€ƒäº†åˆ«äººçš„æ–¹æ³•ï¼Œè§‰å¾—è¿˜æ˜¯ä½¿ç”¨é€’å½’æ¥é€æ­¥è®¡ç®—æ¯”è¾ƒå¥½ï¼Œå› ä¸ºå·¦æ—‹å’Œå³æ—‹åªæœ‰2ç§ï¼Œä½†keyåŒä¸€ä¸ªå­—æ¯çš„ä¸ªæ•°å´ä¸æ­¢2ç§ï¼ŒçŠ¶æ€è¿˜æ˜¯è®¾å®šä¸å¤Ÿåˆ°ä½ï¼Œåº”è¯¥æŠŠæŒ‡é’ˆçš„ä½ç½®ä½œä¸ºiï¼ŒåŒ¹é…æ•°ä½œä¸ºjï¼Œè¿™æ ·è®¡ç®—æ—¶å°±å°‘äº†ä¸€äº›åˆ†å‰ã€‚ æ¯”å¦‚è¦æ‰¾iï¼Œå¦‚æœå‚ç…§ç¬¬ä¸€ç§åšæ³•ï¼Œå°±ä¼šéå†æ‰€æœ‰åˆ°içš„è·¯å¾„ï¼Œè€Œç¬¬äºŒç§åšæ³•å°±åªä¼šå·¦æ—‹å’Œå³æ—‹åˆ°ä¸åŒiçš„ä½ç½®ï¼Œæ‰¾å‡ºæœ€çŸ­çš„ï¼Œä¸å¿…åˆ°éå†åˆ°å¤šä½™çš„iã€‚ æ”¹è‰¯åçš„ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution&#123; public: int findRotateSteps(string ring, string key) &#123; steps = vector&lt;vector&lt;int&gt;&gt;(ring.length(), vector&lt;int&gt;(key.length(), INT_MAX)); return rotate(ring, key, 0, 0) + key.length(); &#125; int rotate(string &amp;ring, string &amp;key, int pointer, int pos) &#123; int right = 0, left = 0; if (pos &gt;= key.size()) &#123; return 0; &#125; if (steps[pointer][pos] != INT_MAX) &#123; return steps[pointer][pos]; &#125; int lp = pointer; int rp = pointer; while (ring[lp] != key[pos]) &#123; lp--; left++; if (lp &lt; 0) //åˆ¤æ–­æ˜¯å¦è¶Šç•Œã€‚ &#123; lp = ring.size() - 1; &#125; &#125; while (ring[rp] != key[pos]) &#123; rp++; right++; if (rp == ring.size()) //åˆ¤æ–­æ˜¯å¦è¶Šç•Œã€‚ &#123; rp = 0; &#125; &#125; left += rotate(ring, key, lp, pos + 1); right += rotate(ring, key, rp, pos + 1); return steps[pointer][pos] = min(left, right); &#125; private: vector&lt;vector&lt;int&gt;&gt; steps;&#125;; ä»£ç åˆ†æ ä½¿ç”¨äº†é€’å½’é¿å…äº†ä¸‰é‡å¾ªç¯ï¼Œä»0ï¼Œ0å¼€å§‹ä¸€ç›´åŒ¹é…ï¼Œè€Œä¸”æ¯ä¸€ä¸ªåˆ†å‰åªæœ‰å·¦æ—‹å’Œå³æ—‹çš„åˆ†å‰ï¼Œå‡å°‘äº†åˆ†å‰çš„æ•°é‡ä»è€Œå°‘è®¡ç®—äº†å¾ˆå¤šçŠ¶æ€ã€‚å…¶ä¸­æœ‰äº›çŠ¶æ€å¯ä»¥è¢«é‡å¤åˆ©ç”¨ï¼Œå°±åƒå¾ˆå¤šæ¡è·¯è‹¥æœ‰ä¸€ä¸ªäº¤å‰ç‚¹ï¼Œé‚£ä¹ˆåé¢çš„æœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹ä¹Ÿæ˜¯äº¤å‰çš„ï¼Œä¸å¿…å†å¾€åç®—ã€‚è¿™åˆå¾ˆåƒä¹‹å‰çš„frog jumpè¿™é“é¢˜ã€‚ä¿®æ”¹åçš„ç®—æ³•å±…ç„¶è¶…è¶Šäº†100%ï¼è¿˜æ˜¯ç¬¬ä¸€æ¬¡ã€‚ã€‚ã€‚ ä¼˜åŒ–åçš„ç»“æœ æ€»ç»“ åŠ¨æ€è§„åˆ’æœ‰æ—¶å€™æ„Ÿè§‰å¹¶ä¸ä¼šè¿™ä¹ˆå®¹æ˜“æƒ³å¾—åˆ°ï¼Œè™½ç„¶éƒ½çŸ¥é“é€šå¸¸è§£æ³•æ˜¯æ„å»ºçŠ¶æ€ï¼Œç¡®è®¤ç­–ç•¥ï¼Œç„¶åè¿›è¡Œé¡ºæ¨æˆ–è€…å€’é€€æ¥å¾—åˆ°ç»“æœã€‚ä½†ä¸åŒçš„é—®é¢˜éƒ½æœ‰ç€ä¸åŒçš„æ€§è´¨å’Œè§£æ³•ï¼Œæ‰€ä»¥è¯´è§£å†³è¿™ç±»é—®é¢˜åªèƒ½ä¾é å¤šç†Ÿæ‚‰è¿™ç±»é—®é¢˜ï¼Œå¤šä¼˜åŒ–å¤šä¿®æ”¹ï¼Œç¬¬ä¸€æ¬¡å¾€å¾€éƒ½å¾—ä¸åˆ°æœ€ä½³çš„è§£æ³•çš„ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://ziquanzhang.ink/tags/Dynamic-Programming/"}]},{"title":"[LeetCode]  828. Unique Letter String","date":"2018-11-05T12:39:00.000Z","path":"2018/11/05/LeetCode-828-Unique-Letter-String/","text":"828. Unique Letter String week9 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° A character is unique in string S if it occurs exactly once in it. For example, in string S = &quot;LETTER&quot;, the only unique characters are &quot;L&quot; and &quot;R&quot;. Letâ€™s define UNIQ(S) as the number of unique characters in string S. For example, UNIQ(&quot;LETTER&quot;) = 2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7. Example1: Input: &quot;ABC&quot; Output: 10 Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;. Evey substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example2: Input: &quot;ABA&quot; Output: 8 Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1. Note: 0 &lt;= S.length &lt;= 10000. é¢˜ç›®åˆ†æ é¢˜æ„æ˜¯æ‰¾å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å­ä¸²ï¼Œå†åœ¨æ¯ä¸ªå­ä¸²ä¸­ç»Ÿè®¡æ‰€æœ‰çš„åªå‡ºç°ä¸€æ¬¡çš„å­—æ¯çš„ä¸ªæ•°ï¼Œæœ€åç»Ÿè®¡æ‰€æœ‰çš„æ¬¡æ•°ä¹‹å’Œè¿›è¡Œè¾“å‡ºã€‚ä¸»è¦æ˜¯å¦‚ä½•æ‰¾å‡ºæ‰€æœ‰å­ä¸²ä¸”è¦è®¡ç®—å•ç‹¬å‡ºç°çš„å­—æ¯ä¸ªæ•°ã€‚ è§£é¢˜æ€è·¯ å¦‚æœæ˜¯æŒ‰ç…§é¢˜ç›®çš„é‚£ç§ä¾‹å­æ¥ç®—ï¼Œç®—å‡ºæ‰€æœ‰çš„å­ä¸²ï¼Œå†åˆ¤æ–­ï¼Œé‚£ä¹ˆä¸€å®šéå¸¸å¤æ‚ï¼Œä¸è¯´å­ä¸²çš„æ•°é‡éå¸¸å¤šï¼Œåˆ¤æ–­ä¹Ÿæ˜¯ä¸€ä¸ªå¤§é—®é¢˜ï¼Œæœ€åè¿˜è¦è¿›è¡Œç»Ÿè®¡ï¼Œè¿™ç§æ–¹æ³•æ˜¯ä¸å¯è¡Œçš„ï¼Œç‰¹åˆ«æ˜¯é¢˜ç›®ç»™å‡ºçš„å­—ç¬¦ä¸²æœ€é•¿æœ‰1wä¸ªå­—ç¬¦ã€‚ æ—¢ç„¶æ­£å‘æ–¹æ³•ä¸å¯è¡Œï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•ä½¿ç”¨æ„é€ çš„æ–¹æ³•ï¼Œå³æ ¹æ®å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€ä¸ªå­—æ¯ç‰¹æ®Šæ„é€ å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè‹¥è¯¥å­—ç¬¦ä¸²å±äºå­—ä¸²ï¼Œåˆ™ç¬¦åˆ+1ï¼Œå› æ­¤é¢˜ç›®ä¹Ÿå°±è½¬å˜æˆäº†æ¯ä¸€ä¸ªå­—æ¯åŒ…å«å…¶çš„å­ä¸²æœ‰å¤šå°‘ä¸ªã€‚ å› ä¸ºæœ‰æ¡ä»¶é™åˆ¶ï¼Œä¸”å­—æ¯çš„ä½ç½®å›ºå®šï¼Œå› æ­¤å¯ä»¥å¾ˆè½»æ¾çš„åˆ¤æ–­åŒ…å«æŸä¸ªå­—æ¯çš„å­ä¸²æœ‰å¤šå°‘ä¸ªï¼Œä¾‹å¦‚A***A**A,è¿™ç§ï¼Œè‹¥è¦åˆ¤æ–­åŒ…å«ä¸­é—´çš„Aæœ‰å¤šå°‘å­ä¸²ï¼Œå› ä¸ºæœ‰æ¡ä»¶é™åˆ¶ä¸èƒ½è¶…è¿‡1ä¸ªAï¼Œæ‰€ä»¥å°±é™åˆ¶åœ¨äº†***A**ä¹‹ä¸­é€‰æ‹©ï¼Œæ ¹æ®æ’åˆ—ç»„åˆï¼Œå·¦è¾¹æœ‰4ç§é€‰æ‹©ï¼Œå³è¾¹æœ‰3ç§é€‰æ‹©ï¼Œæ‰€ä»¥å­ä¸²ä¸º3*4 = 12ã€‚ å› æ­¤å¾—åˆ°æ–¹æ³•ï¼šå°†å­—æ¯å·¦è¾¹çš„å…¶å®ƒå­—æ¯æ•°*å³è¾¹å…¶å®ƒå­—æ¯æ•°å³ä¸ºå­ä¸²æ•°ç›®ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829class Solution&#123; public: int uniqueLetterString(string S) &#123; vector&lt;int&gt; letter[26]; for (int i = 0; i &lt; 26; i++) &#123; letter[i].push_back(-1); &#125; for (int i = 0; i &lt; S.length(); i++) &#123; letter[S[i] - 'A'].push_back(i); &#125; for (int i = 0; i &lt; 26; i++) &#123; letter[i].push_back(S.length()); &#125; int result = 0; for (int i = 0; i &lt; 26; i++) &#123; for (int j = 1; j &lt; letter[i].size() - 1; j++) &#123; result += (letter[i][j + 1] - letter[i][j]) * (letter[i][j] - letter[i][j - 1]); &#125; &#125; return result % 1000000007; &#125;&#125;; Note è€ƒè™‘åˆ°æœ‰å¯èƒ½åœ¨å­—ç¬¦ä¸²çš„è¾¹ç•Œè¿™ç§æƒ…å†µï¼Œå› æ­¤å°†è¾¹ç•Œè€ƒè™‘åœ¨å†…è¿›è¡Œè®¡ç®—ï¼Œä»è€Œæ›´åŠ æ–¹ä¾¿è¿›è¡Œè®¡ç®—è€Œæ— éœ€åå¤åˆ¤æ–­ï¼Œå’ŒäºŒåˆ†æ³•ç±»ä¼¼ã€‚ ä½¿ç”¨äº†vectoræ•°ç»„å°†ä¸åŒå­—æ¯åˆ†å¼€ï¼Œå› ä¸ºè¿™ä¸ªè®¡ç®—æœ€å…³é”®çš„æ˜¯æ‰¾åˆ°ä¸¤è¾¹çš„åŒç§å­—æ¯å’Œè¾¹ç•Œæ¥è®¡ç®—å‡ºå…¶å­ä¸²ï¼Œæ‰€ä»¥å…ˆè®°å½•ä½ç½®å†åˆ†å¼€è®¡ç®—æ¯”è¾ƒå¥½ã€‚ Unique Letter String_test æœ€ä½³è§£æ³• å‚è€ƒä»£ç  12345678910111213int uniqueLetterString(string S) &#123; int index[26][2], res = 0, N = S.length(), mod = pow(10, 9) + 7; memset(index, -1, sizeof(int) * 52); for (int i = 0; i &lt; N; ++i) &#123; int c = S[i] - 'A'; res = (res + (i - index[c][1]) * (index[c][1] - index[c][0]) % mod) % mod; index[c][0] = index[c][1]; index[c][1] = i; &#125; for (int c = 0; c &lt; 26; ++c) res = (res + (N - index[c][1]) * (index[c][1] - index[c][0]) % mod) % mod; return res;&#125; ä»£ç åˆ†æ åœ¨ç½‘ä¸Šçš„è®¨è®ºä¸­å‘ç°äº†ä¸€ä¸ªæ›´åŠ å¿«çš„ä»£ç ï¼Œè¿™ä¸ªæ€è·¯å’Œä¸Šé¢çš„æ€è·¯ç›¸ä¼¼ï¼Œéƒ½æ˜¯è®¡ç®—å­ä¸²æ•°ï¼Œä¸è¿‡è¿™ä¸ªç”¨äº†è¾¹è®°å½•è¾¹ç®—æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬æ¯æ¬¡ç®—åªéœ€è¦çŸ¥é“ç›®æ ‡ä½ç½®ä»¥åŠä¸¤è¾¹çš„è¾¹ç•Œå³å¯ï¼Œè¿™ä¸ªå°±æ˜¯åˆ©ç”¨äº†è¿™ä¸€ç‚¹åªè®°å½•äº†ä¸Šä¸¤æ¬¡åŒå­—æ¯çš„ä½ç½®ï¼ŒåŠ ä¸Šç¬¬ä¸‰æ¬¡å°±å¯è®¡ç®—ä¸­é—´çš„å­ä¸²æ•°ã€‚ä¸è¿‡è¿™ä¸ªåšæ³•æ²¡æœ‰ç®—å®Œï¼Œè¦åœ¨æœ€åçš„æ—¶å€™å†åŠ ä¸ŠåŒ…å«æœ€åå­—æ¯çš„å­ä¸²æ•°ã€‚ è¿™ç§æ–¹æ³•é‡å¤åˆ©ç”¨äº†ç©ºé—´ï¼Œå‡å°‘äº†éå†çš„æ¬¡æ•°ï¼Œå¾ˆå€¼å¾—å­¦ä¹ ã€‚å¯èƒ½æœ‰æ—¶å€™è¿™ç‚¹æ—¶é—´å°±èƒ½å†³å®šèƒ½ä¸èƒ½ACã€‚è¯¦ç»†çš„æ€è·¯åˆ†æ æ€»ç»“ è¿™é“é¢˜ä¸»è¦æ˜¯é”»ç‚¼æˆ‘ä»¬æ€è€ƒé—®é¢˜æ—¶çš„è½¬åŒ–èƒ½åŠ›ï¼Œæ€ä¹ˆæ ·æŠŠé—®é¢˜è½¬åŒ–æˆç®€å•çš„é—®é¢˜ï¼Œé€†å‘æ€è·¯è§£å†³ã€‚å¦å¤–å¦‚ä½•è®¡ç®—åŒ…å«æŸç‰¹å®šä½ç½®çš„å­ä¸²ä¹Ÿæ˜¯ä¸€ç§å€¼å¾—æ€è€ƒçš„åœ°æ–¹ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"åŒºå—é“¾çƒ­èº«æŠ¥å‘Š","date":"2018-11-04T13:17:00.000Z","path":"2018/11/04/åŒºå—é“¾çƒ­èº«æŠ¥å‘Š/","text":"åŒºå—é“¾çƒ­èº«æŠ¥å‘Š 16340296 å¼ å­æƒ ä»¥å¤ªåŠçš„å®‰è£…ã€ç§æœ‰é“¾åˆ›ä¸–åŒºå—æ­å»ºã€ç§æœ‰é“¾èŠ‚ç‚¹çš„åŠ å…¥(é€‰åš) å®‰è£…ä»¥å¤ªåŠ ä»http://ethereum.github.io/go-ethereum/downloads/ ä¸‹è½½å®‰è£…Gethï¼Œå¯èƒ½éœ€è¦åœ¨windowsä¸‹æ·»åŠ ç¯å¢ƒå˜é‡ã€‚ ç§æœ‰é“¾åˆ›ä¸–åŒºå—æ­å»º æ–°å»ºä¸€ä¸ªgenesis.jsonï¼Œè®¾ç½®åˆ›ä¸–åŒºå—çš„éš¾åº¦,idç­‰å‚æ•°ã€‚æ–°å»ºæ–‡ä»¶å¤¹dataã€‚ åˆå§‹åŒ–åˆ›ä¸–åŒºå—ï¼š 1geth --datadir data/ init genesis.json å¯åŠ¨èŠ‚ç‚¹å¹¶è¿›å…¥äº¤äº’å¼æ§åˆ¶å°ï¼š 1geth --datadir data --networkid 1008 --ipcdisable --port 1001 --rpcport 8001 --verbosity=4 console 2&gt;&gt;output.log ç§æœ‰é“¾èŠ‚ç‚¹çš„åŠ å…¥ å†æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ä¸ºdata0ã€‚ å¯åŠ¨èŠ‚ç‚¹å¹¶è¿›å…¥äº¤äº’å¼æ§åˆ¶å°ï¼š 1geth --datadir data0 --networkid 1008 --ipcdisable --port 1003 --rpcport 80222 console åœ¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸­ä½¿ç”¨admin.nodeInfo.enodeè·å–enodeã€‚ åœ¨ç¬¬äºŒä¸ªèŠ‚ç‚¹ä¸­æ·»åŠ ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ 1admin.addPeer(\"enode://e9e7ad186217fbf7b7d7185695dcd17afa73d23e1a1365dd96d01327aee87b2b95af8ca3857ce6b1f6a7d26c58abc19f5e0846787a1d35e21cab7c5fea0cee2a@[::]:1001\") å†ä½¿ç”¨admin.peerså¯å¾—åˆ°åŠ å…¥èŠ‚ç‚¹çš„ä¿¡æ¯ã€‚ 1234567891011121314151617181920[&#123; caps: [\"eth/62\", \"eth/63\"], enode: \"enode://e9e7ad186217fbf7b7d7185695dcd17afa73d23e1a1365dd96d01327aee87b2b95af8ca3857ce6b1f6a7d26c58abc19f5e0846787a1d35e21cab7c5fea0cee2a@[::]:1001\", id: \"e4a6cb32cfb6b641dd2606bdb67571f63ff80ff1fe4883c1aa46cd5b89e110eb\", name: \"Geth/v1.8.17-stable-8bbe7207/windows-amd64/go1.11.1\", network: &#123; inbound: false, localAddress: \"127.0.0.1:18752\", remoteAddress: \"127.0.0.1:1001\", static: true, trusted: false &#125;, protocols: &#123; eth: &#123; difficulty: 85380105, head: \"0xd2c073c35fb027d8dd8fe4d95174bc82ca93d96599dfb05e8deee320631621f0\", version: 63 &#125; &#125;&#125;] å¯¹ getBlock ä¸­æ‰€å¾—åŒºå—çš„å„ä¸ªå­—æ®µè¿›è¡Œè§£é‡Š å­—æ®µ ç±»å‹ æ„ä¹‰ difficulty BigNumber è¡¨ç¤ºå½“å‰åŒºå—çš„éš¾åº¦ï¼Œæ ¹æ®å‰ä¸€ä¸ªåŒºå—çš„éš¾åº¦å’Œæ—¶é—´æˆ³è®¡ç®—å¾—åˆ°ï¼Œå¯çŸ¥å½“å‰åŒºå—1éš¾åº¦ä¸º131072 extraData String æŒ‡çš„æ˜¯é™„åŠ ä¿¡æ¯ï¼Œå¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€è¦å¡«å†™ä¿¡æ¯ã€‚32å­—èŠ‚ä»¥å†…çš„å­—èŠ‚æ•°ç»„ã€‚ gasLimit Number è¡¨ç¤ºå½“å‰åŒºå—å…è®¸ä½¿ç”¨çš„æœ€å¤§gasï¼ŒæŒ‡è¿™ç¬”äº¤æ˜“æœ€å¤šåªèƒ½ç»™çŸ¿å·¥è¿™ä¹ˆå¤šgasï¼Œè‹¥ç”¨ä¸å®Œåˆ™è¿”å›å¤šå‡ºçš„gasè¿”å›ï¼Œä½†å¦‚æœgaslimitä¸è¶³ä»¥æ”¯ä»˜äº¤æ˜“ï¼Œé‚£ä¹ˆä¸ä¼šé€€å›ï¼Œå› ä¸ºä»¥å¤ªåŠè§„å®šæ¯ç¬”äº¤æ˜“gasæœ€å°‘ä¸º21000ï¼Œæ‰€ä»¥ä¸€å®šè¦å¤§äº21000ã€‚åŒç†è‹¥åˆçº¦çš„gaslimitå°äºåŒºå—çš„gaslimitåˆ™éƒ¨ç½²ä¸äº†ã€‚ gasUsed Number å’ŒgasLimitç›¸å¯¹ï¼Œä¸ºå½“å‰åŒºå—æ‰€ç´¯ç§¯ä½¿ç”¨çš„gaså€¼ã€‚ hash String æŒ‡è¯¥åŒºå—çš„å“ˆå¸Œå€¼ï¼Œå½“åŒºå—ç­‰å¾…è¢«åŒºå—é“¾ç¡®è®¤æ—¶ï¼Œåˆ™ä¸ºnullï¼Œå¯ä»¥è®¤ä¸ºæ˜¯åŒºå—åœ¨æ•´ä¸ªåŒºå—é“¾çš„ç´¢å¼•ã€‚ logsBloom String æ—¥å¿—Bloomè¿‡æ»¤å™¨ï¼Œä¿¡æ¯åŒ…å«åœ¨æ¯ä¸ªæ—¥å¿—å…¥å£, æ¥è‡ªäº¤æ˜“åˆ—è¡¨ä¸­æ¯ä¸ªäº¤æ˜“çš„æ¥å—è€…ã€‚ miner String è¡¨ç¤ºæ‰“åŒ…è¿™ä¸€åŒºå—çš„çŸ¿å·¥çš„åœ°å€ã€‚ mixHash String æ··åˆå“ˆå¸Œï¼Œä¸nonceè¿›è¡Œå“ˆå¸Œè¿ç®—ï¼Œè¯æ˜å·²ç»ä»˜å‡ºäº†è¶³å¤Ÿçš„å·¥ä½œé‡ã€‚ nonce String ä¸€ä¸ªéšæœºæ•°64ä½å“ˆå¸Œï¼Œè¡¨ç¤ºè¯¥çŸ¿å·¥æ‰¾åˆ°çš„ç¬¦åˆæ¡ä»¶çš„nonceå€¼ã€‚ number Number ä¸ºåŒºå—ç¼–å·ï¼ŒæŒ‡è¯¥åŒºå—ä¸ºç¬¬å‡ ä¸ªåŒºå—ã€‚ parentHash String çˆ¶å“ˆå¸Œï¼ŒæŒ‡ä¸Šä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ã€‚å› ä¸ºåˆ›ä¸–åŒºå—æ²¡çˆ¶åŒºå—ï¼Œæ‰€ä»¥è¿™ä¸ªå€¼ä¸º0ã€‚ receiptsRoot String äº¤æ˜“å®Œæˆåï¼Œç”±äº¤æ˜“æ”¶æ®ï¼Œæ—¥å¿—å†…å®¹æ„æˆçš„æ•°æ®çš„å­—å…¸æ ‘æ ¹èŠ‚ç‚¹å“ˆå¸Œã€‚ sha3Uncles String ç±»ä¼¼ä¸Šä¸€ä¸ªï¼ŒæŒ‡ç”±å”åŒºå—å“ˆå¸Œæ„æˆçš„å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹å“ˆå¸Œã€‚ size Number å½“å‰è¿™ä¸ªåŒºå—çš„å­—èŠ‚å¤§å°ã€‚ stateRoot String çŠ¶æ€å­—å…¸æ ‘æ ¹èŠ‚ç‚¹çš„å“ˆå¸Œã€‚ timestamp Number æŒ‡å½“å‰è¯¥åŒºå—åˆå§‹åŒ–æ—¶çš„Unixæ—¶é—´æˆ³ã€‚ totalDifficulty Number åˆ°å½“å‰åŒºå—ä¸ºæ­¢ï¼Œæ‰€ç§¯ç´¯çš„æ‰€æœ‰åŒºå—éš¾åº¦ä¹‹å’Œã€‚ transactions æ•°ç»„ å½“å‰åŒºå—æ‰€åŒ…å«çš„äº¤æ˜“ã€‚ transactionsRoot String åŒ…å«æ‰€æœ‰äº¤æ˜“çš„äº¤æ˜“å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹å“ˆå¸Œå€¼ã€‚ Uncles æ•°ç»„ åŒ…å«å½“å‰åŒºå—çš„æ‰€ä»¥å”åŒºå—ã€‚ å¯¹æ—¥å¿—è¾“å‡ºè¿›è¡Œè§£é‡Š åˆå§‹åŒ–åŒºå—é“¾ï¼Œåˆ†é…æ–‡ä»¶å¤¹å’Œç©ºé—´ï¼Œå†™å…¥åˆ›ä¸–å—ï¼ŒæŒä¹…åŒ–å­—å…¸æ ‘ã€‚ 1234567INFO [11-04|15:30:01.915] Allocated cache and file handles database=\"D:\\\\Program Files\\\\Geth\\\\data\\\\geth\\\\chaindata\" cache=16 handles=16INFO [11-04|15:30:01.940] Writing custom genesis blockINFO [11-04|15:30:01.941] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [11-04|15:30:01.941] Successfully wrote genesis state database=chaindata hash=5e1fc7â€¦790e0 å¼€å§‹è¿æ¥æ—¶ï¼Œåˆå§‹åŒ–ä»¥å¤ªåŠåè®®ï¼Œè½½å…¥æœ€è¿‘çš„åŒºå—ï¼Œé‡æ–°åŠ è½½äº¤æ˜“å’Œç”Ÿæˆäº¤æ˜“æ—¥å¿—ã€‚ 12345678910INFO [11-04|15:31:05.759] Initialising Ethereum protocol versions=\"[63 62]\" network=1008INFO [11-04|15:31:05.759] Loaded most recent local header number=0 hash=5e1fc7â€¦790e0 td=131072 age=49y6mo2wINFO [11-04|15:31:05.760] Loaded most recent local full block number=0 hash=5e1fc7â€¦790e0 td=131072 age=49y6mo2wINFO [11-04|15:31:05.760] Loaded most recent local fast block number=0 hash=5e1fc7â€¦790e0 td=131072 age=49y6mo2wDEBUG[11-04|15:31:05.760] Reinjecting stale transactions count=0INFO [11-04|15:31:05.762] Regenerated local transaction journal transactions=0 accounts=0 è¾“å…¥exitå…³é—­è¿æ¥ï¼Œä¹‹åå°†ç¼“å­˜ä¸­çš„çŠ¶æ€å†™å…¥ç£ç›˜æŒä¹…åŒ–æ•°æ®ï¼Œå…³é—­åŒºå—é“¾ï¼Œå…³é—­åè®®å’Œäº¤æ˜“æ± ï¼Œæœ€åå…³é—­æ•°æ®åº“ã€‚ 123456789101112131415INFO [11-04|17:11:41.533] Writing cached state to disk block=454 hash=4713ecéˆ¥?7d4ca root=a006fféˆ¥î›‹e94eaINFO [11-04|17:11:41.533] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gc time=0s livenodes=1 livesize=0.00BINFO [11-04|17:11:41.533] Blockchain manager stoppedINFO [11-04|17:11:41.533] Stopping Ethereum protocolINFO [11-04|17:11:41.533] Ethereum protocol stoppedINFO [11-04|17:11:41.533] Transaction pool stoppedINFO [11-04|17:11:41.533] Database closed database=\"D:\\\\Program Files\\\\Geth\\\\data\\\\geth\\\\chaindata\" çŸ¿å·¥æŒ–çŸ¿ï¼Œæ‰“åŒ…æ–°åŒºå—ï¼Œå¼€é‡‡æ½œåœ¨çš„åŒºå—ã€‚ 123INFO [11-04|17:30:48.082] Commit new mining work number=593 sealhash=108a77â€¦bbb5d6 uncles=0 txs=0 gas=0 fees=0 elapsed=35.904msINFO [11-04|17:30:49.212] Successfully sealed new block number=593 sealhash=108a77â€¦bbb5d6 hash=c52790â€¦332920 elapsed=1.166sINFO [11-04|17:30:49.217] ğŸ”¨ mined potential block number=593 hash=c52790â€¦332920 æäº¤äº¤æ˜“ã€‚ 123INFO [11-04|18:25:09.342] Setting new local account address=0x15b97213fB8ee04D2ed53113E41035FEaE88461eINFO [11-04|18:25:09.346] Submitted transaction fullhash=0x889aa5bb7bc45463a5f59012b2ac15abdce71542a48bc6a6be91969c48eac6a5 recipient=0x6a949Cd94E739d035d13c2242B32093553567361\"0x889aa5bb7bc45463a5f59012b2ac15abdce71542a48bc6a6be91969c48eac6a5\" éšåé€šè¿‡æŒ–çŸ¿å‘ç°æœ‰ä¸€gas=420000çš„åŒºå—ã€‚ 1INFO [11-04|18:32:42.760] Commit new mining work number=607 sealhash=916deaâ€¦38331b uncles=0 txs=2 gas=42000 fees=4.2e-05 elapsed=8.943ms æ·»åŠ èŠ‚ç‚¹ã€‚ 12INFO [11-04|18:39:56.578] Block synchronisation startedINFO [11-04|18:39:56.709] Imported new chain segment blocks=26 txs=7 mgas=0.126 elapsed=111.730ms mgasps=1.128 number=607 hash=d2c073â€¦1621f0 age=7m14s cache=17.84kB ignored=2 ç¼–å†™ç®€å•çš„æ™ºèƒ½åˆçº¦ï¼Œåœ¨ remix ä¸‹è¿›è¡Œè°ƒè¯•ï¼Œå¹¶éƒ¨ç½²åœ¨é“¾ä¸Šè¿›è¡Œè°ƒç”¨ ç¼–å†™ç®€å•çš„æ™ºèƒ½åˆçº¦ ç¼–å†™ä¸€ä¸ªç±»ä¼¼ä¸å¤è¯»æœºçš„ä¸œè¥¿ï¼Œå‘é€å­—ç¬¦ä¸²ä¿å­˜ï¼Œä¹‹åå¤è¯»å‘é€çš„è¯ã€‚ solidityä»£ç ï¼š 12345678910111213141516171819contract AI &#123; string box; function send(string s) public &#123; box = s; &#125; function clear() public&#123; box = \"\"; &#125; function receive() public constant returns (string) &#123; return box; &#125; function greet() public constant returns (string) &#123; return \"hello\"; &#125;&#125; è¿›è¡Œè°ƒè¯•éƒ¨ç½²è°ƒç”¨ éƒ¨ç½²åˆçº¦ è¿›è¡ŒæŒ–çŸ¿åæˆåŠŸéƒ¨ç½²ã€‚ greet å‘é€ä¿¡æ¯ï¼Œäº§ç”Ÿäº¤æ˜“ï¼ŒæŒ–çŸ¿åäº¤æ˜“æˆåŠŸã€‚ äº¤æ˜“æˆåŠŸåæ›´æ–°é‡Œé¢çš„stringï¼Œå†ç”¨receiveå¾—åˆ°åˆšåˆšçš„æ¶ˆæ¯ã€‚ æ¸…é™¤æ¶ˆæ¯ï¼Œä¹Ÿéœ€è¦äº§ç”Ÿäº¤æ˜“ï¼Œç„¶åæŒ–çŸ¿ä½¿äº¤æ˜“æˆåŠŸã€‚ å¯¹äº¤æ˜“çš„å­—æ®µè¿›è¡Œè§£é‡Š æ ¹æ®ä»¥ä¸Š3çš„å‘é€æ¶ˆæ¯çš„äº¤æ˜“è¿›è¡Œè§£é‡Šã€‚ 1234567891011121314151617eth.getTransaction(\"0xeb7a55e1760ecc986f813c881b76ab12b812bc611f8f6b9cacb69248438b50ec\")&#123; blockHash: \"0x06258165d31d4ea7ed945fa430d8e25f75690c0ae20ca4d2ae8f6de40576d261\", blockNumber: 642, from: \"0x15b97213fb8ee04d2ed53113e41035feae88461e\", gas: 43406, gasPrice: 1000000000, hash: \"0xeb7a55e1760ecc986f813c881b76ab12b812bc611f8f6b9cacb69248438b50ec\", input: \"0x66792ba10000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000ce5bc80e5a78be5a48de8afbb0000000000000000000000000000000000000000\", nonce: 14, r: \"0x3892abe334fbe797ce57155373c9c36860121d143950f873e554dc37321847d\", s: \"0x55eea1e92c492bd89f7db381fda08ae795fdc7abdbcff4c98f897cae94edae7c\", to: \"0x2eb0f4a6c064c51033dbc5977973bcb6702a9cdd\", transactionIndex: 0, v: \"0x37\", value: 0&#125; å­—æ®µåç§° ç±»å‹ æ„ä¹‰ blockHash String äº¤æ˜“æ‰€å¤„åŒºå—çš„å“ˆå¸Œå€¼ blockNumber Number å½“å‰äº¤æ˜“æ‰€å¤„åœ¨åŒºå—çš„ç¼–å· from String å‘èµ·äº¤æ˜“çš„è´¦æˆ·ï¼ˆåœ°å€ï¼‰ gas Number å®Œæˆè¿™ç¬”äº¤æ˜“æ‰€éœ€è¦çš„gas gasPrice Number å½“å‰æ¯ä¸ªgasæ‰€éœ€çš„èŠ±è´¹ hash String å½“å‰äº¤æ˜“çš„å“ˆå¸Œå€¼ input String éƒ¨ç½²æ™ºèƒ½åˆçº¦äº¤æ˜“çš„16è¿›åˆ¶ä»£ç ï¼Œåˆçº¦è°ƒç”¨ç›¸å…³çš„äºŒè¿›åˆ¶ä¿¡æ¯ nonce Number ç›¸å½“äºå‘èµ·äººçš„äº¤æ˜“åºå·ï¼Œæ¯å‘é€ä¸€ç¬”äº¤æ˜“ï¼Œnonce+1ï¼Œæ”¾ç½®äº¤æ˜“é‡å¤è¿›è¡Œ r String å‘èµ·äººEOAçš„ECDSAç­¾åçš„ä¸‰ä¸ªç»„æˆéƒ¨åˆ† s String å‘èµ·äººEOAçš„ECDSAç­¾åçš„ä¸‰ä¸ªç»„æˆéƒ¨åˆ† to String ç›®æ ‡ä»¥å¤ªåŠåœ°å€ transactionIndex Number äº¤æ˜“ç´¢å¼• v String å‘èµ·äººEOAçš„ECDSAç­¾åçš„ä¸‰ä¸ªç»„æˆéƒ¨åˆ† values Number è¦å‘é€åˆ°ç›®çš„åœ°å€çš„ä»¥å¤ªå¸æ•°","tags":[{"name":"ethereum","slug":"ethereum","permalink":"http://ziquanzhang.ink/tags/ethereum/"}]},{"title":"[LeetCode] 45. Jump Game II","date":"2018-10-28T13:57:00.000Z","path":"2018/10/28/LeetCode-45-Jump-Game-II/","text":"45. Jump Game II week8 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Note: The number of stones is â‰¥ 2 and is &lt; 1,100. Each stoneâ€™s position will be a non-negative integer &lt; 231. The first stoneâ€™s position is always 0. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. é¢˜ç›®åˆ†æ è¿™é“é¢˜ç›®ååˆ†ç®€å•ï¼Œå°±æ˜¯ç»™äºˆä¸€ä¸ªæ•°ç»„ï¼Œä½¿å¾—ä¸€å¼€å§‹åœ¨æ•°ç»„çš„é¦–å…ƒç´ ä¸­ï¼Œèƒ½å¤Ÿè·³è¶Šåˆ°æœ€åä¸€é¡¹ï¼Œè€Œæ¯é¡¹ä¸­çš„æ•°å­—å³è·³è·ƒçš„æé™èŒƒå›´ã€‚ç»™å‡ºæœ€å¿«åˆ°è¾¾æ•°ç»„å°¾çš„æ­¥æ•°ã€‚ è§£é¢˜æ€è·¯ å’Œä¸Šä¸€å‘¨æ‰€åšçš„é’è›™è·³ååˆ†ç±»ä¼¼ï¼Œä½†åˆä¸å¤ªä¸€æ ·ï¼Œå› ä¸ºè¿™æ¬¡çš„åªç»™å‡ºäº†è·³è¶Šçš„æé™ï¼Œæ‰€ä»¥èŒƒå›´å¯ä»¥é€‰æ‹©0~xï¼Œä½¿å¾—å‡ ä¹éƒ½å¯ä»¥åˆ°è¾¾ç»ˆç‚¹ã€‚ æ—¢ç„¶æ˜¯è¿™æ ·çš„è¯ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¸éœ€è¦è¿›è¡Œåˆ†æ”¯é¢„æµ‹å’Œåˆ¤æ–­äº†ï¼Œç›´æ¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼Œè´ªå¿ƒç­–ç•¥å¹¶ä¸æ˜¯æ¯æ¬¡éƒ½èµ°åˆ°æœ€è¿œçš„è·ç¦»ï¼Œè€Œæ˜¯æ ¹æ®åˆ°è¾¾çš„é¡¶ç‚¹ä¹‹åæ‰€èƒ½è¾¾åˆ°çš„æœ€å¤§è·ç¦»ã€‚è¿™æ ·å°±èƒ½ä¿è¯æ¯ä¸€ä¸ªçš„è·ç¦»éƒ½æ˜¯ç”±ä¸Šä¸€ä¸ªçš„æœ€è¿œè·ç¦»è€Œæ¥ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0 || nums.size() == 1)&#123; return 0; &#125; int maxjump = nums[0]; int steps = 0; int index = 0; for(; index &lt;= maxjump &amp;&amp; index &lt; nums.size() - 1;)&#123; steps++; if(maxjump &gt;= nums.size() -1)&#123; return steps; &#125; int nextjump = maxjump; int start = index; for(int i = nextjump; i &gt;= start; i--)&#123; if(i + nums[i] &gt; maxjump)&#123; maxjump = i + nums[i]; index = i; &#125; &#125; &#125; return -1; &#125;&#125;; Note è¿™ä¸ªè´ªå¿ƒç­–ç•¥çš„è¯æ˜å¯ä»¥æ ¹æ®é€’å½’æ¥è¯´æ˜ï¼Œå³å·²ç»åˆ°è¾¾äº†ç»ˆç‚¹ï¼Œé‚£ä¹ˆè¦å¯»æ‰¾è¾¾åˆ°ç»ˆç‚¹çš„æœ€è¿œçš„èµ·ç‚¹ï¼Œä¸æ–­åœ°å¾€å‰å›æº¯ï¼Œæœ€åå¯ä»¥å¾—çŸ¥æ¯ä¸€æ¬¡åˆ¤æ–­ä¸‹ä¸€ä¸ªé¡¶ç‚¹çš„æœ€è¿œè·ç¦»æ¥é€‰æ‹©ä¸‹ä¸€ä¸ªè·³ç‚¹ï¼Œèƒ½å¤Ÿæœ€å¿«åˆ°è¾¾ç»ˆç‚¹ã€‚ è¿™ä¸ªç®—æ³•åŒé’è›™è·³çŸ³å¤´ä¸€æ ·å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä»å½“å‰å¯è·³è¶Šçš„æœ€è¿œè·ç¦»çš„é¡¶ç‚¹å¼€å§‹éå†ï¼Œé‚£ä¹ˆå¾ˆæœ‰å¯èƒ½ç¬¬ä¸€æ¬¡å°±å¾—åˆ°æœ€ä½³è·³ç‚¹ï¼Œå°±ä¸ç”¨ç»å¸¸è¿›è¡Œèµ‹å€¼è¿ç®—ã€‚ç»è¿‡ä¼˜åŒ–åçš„ç®—æ³•å¯ä»12msé™ä¸º8msã€‚ Jump Game II_test æ€»ç»“ æœ€è¿‘åˆšå­¦ä¹ è´ªå¿ƒç®—æ³•ï¼Œæ°å¥½ç”¨ä¸€ä¸‹ï¼Œè¿™ä¸ªé¢˜ç›®çš„å…³é”®ä¹‹å¤„åœ¨äºæ€ä¹ˆå»è¯æ˜è´ªå¿ƒæ˜¯å¯è¡Œçš„ï¼Œæœ‰å¯èƒ½ä¸ä¸€å®šè´ªå¿ƒå°±å¯ä»¥ï¼Œå°±åƒä¸Šä¸€å‘¨é’è›™è·³çš„é¢˜ç›®ï¼Œä½¿ç”¨è´ªå¿ƒç®—æ³•æ—¶ä¸€å®šè¦æ³¨æ„æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 403. Frog Jump","date":"2018-10-19T08:13:00.000Z","path":"2018/10/19/LeetCode-403-Frog-Jump/","text":"403. Frog Jump week7 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stonesâ€™ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit. If the frogâ€™s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction. Note: The number of stones is â‰¥ 2 and is &lt; 1,100. Each stoneâ€™s position will be a non-negative integer &lt; 231. The first stoneâ€™s position is always 0. Example1: [0,1,3,5,6,8,12,17] There are a total of 8 stones. The first stone at the 0th unit, second stone at the 1st unit, third stone at the 3rd unit, and so on... The last stone at the 17th unit. Return true. The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example2: [0,1,2,3,4,8,9,11] Return false. There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. é¢˜ç›®åˆ†æ è‘—åçš„é’è›™è·³çŸ³å¤´é—®é¢˜ï¼Œåœ¨å¤§ä¸€çš„æ—¶å€™ä¸€æ¬¡ACMæ¯”èµ›ä¸­ç¢°åˆ°ä¸€æ¬¡ï¼Œè²Œä¼¼æ˜¯åŸé¢˜ï¼Œç»“æœå¾ˆæ˜¾ç„¶æ‰‘è¡—äº†ï¼Œç°åœ¨çœ‹åˆ°é¢˜ç›®æ‰ç®—æ­£å¼ç†è§£äº†é¢˜ç›®ã€‚ã€‚ã€‚æƒ³æ¥å½“æ—¶æ²¡æœ‰å­¦ä¹ ä»€ä¹ˆæ•°æ®ç»“æ„ä¹Ÿæ˜¯åšä¸å‡ºçš„äº†ï¼Œæš´åŠ›AKæ˜æ˜¾ä¼štimelimitã€‚ é’è›™è·³çŸ³å¤´çš„é¢˜æ„æ˜¯æœ‰ä¸€åªé’è›™è¦è¿‡æ²³ï¼Œæ²³æµåˆ†æˆXä¸ªéƒ¨åˆ†ï¼Œæœ‰çš„åœ°æ–¹æœ‰çŸ³å¤´ï¼Œæœ‰çš„æ²¡æœ‰ã€‚è€Œè¿™åªé’è›™è¦è¿ç»­è·³è¿‡å»ï¼Œå¯èƒ½è¿™åªé’è›™çš„æ‰‹åˆ¹æœ‰ç‚¹æ¯›ç—…ï¼Œæ¯å½“è·³è¿‡Kä¸ªå•ä½æ—¶ï¼Œä¸‹ä¸€æ¬¡è·³è¶Šè¦æ˜¯K-1ã€Kæˆ–è€…K+1ä¸ªå•ä½ï¼Œå¹¶ä¸”åªèƒ½å‘å‰ã€‚ ä¸€å¼€å§‹çš„ç†è§£æ˜¯åªè¦åˆ¤æ–­ä¸‹ä¸€å—çŸ³å¤´æ˜¯å¦åœ¨è·³è¶ŠèŒƒå›´å†…å°±è¡Œäº†ï¼Œä½†æ³¨æ„çš„æ˜¯é’è›™å¯ä»¥é£è¿‡æŸä¸€å—çŸ³å¤´ï¼Œæ‰€ä»¥å°±æœ‰å¾ˆå¤šç§è·³è¶Šæ–¹å¼ï¼Œå‡è®¾æœ‰ä¸¤æ¡è·¯å¾„èƒ½åˆ°è¾¾ç‚¹Aï¼Œé€šè¿‡ä¸åŒè·¯å¾„ååˆ°è¾¾ç‚¹Aåï¼Œå…¶ä¸‹ä¸€æ­¥çš„è·³è¶ŠèŒƒå›´ï¼ˆèƒ½åŠ›ï¼‰ä¹Ÿä¼šä¸ä¸€æ ·ï¼Œæ‰€ä»¥æƒ…å†µä¼šå¾ˆå¤æ‚ã€‚ ç¬¬ä¸€æ¬¡è§£é¢˜æ€è·¯ ç”±äºé’è›™çš„é€‰æ‹©è·¯å¾„çš„å¤šå˜ï¼Œä¼šå¼•èµ·åç»­çš„è·³è¶Šï¼Œå› æ­¤å®ƒçš„é€‰æ‹©åˆ†æ”¯æ˜¯ä»ç¬¬ä¸€æ¬¡å°±å¼€å§‹äº†ï¼Œè¯•æƒ³ä¸€ä¸‹æ¯ä¸ªåˆ†æ”¯åˆä¼šè¡ç”Ÿä¸åŒçš„åˆ†æ”¯ï¼Œé‚£ä¸å°±æ˜¯ä¸€é¢—è·¯å¾„æ ‘äº†å—ï¼Œåªè¦éå†è¿™ä¸€æ£µæ ‘ï¼Œæ‰¾åˆ°æŸä¸€è·¯å¾„å¯ä»¥åˆ°è¾¾ç»ˆç‚¹å³å¯ï¼Œå› ä¸ºåªéœ€è¦å¾—å‡ºé’è›™æ˜¯å¦èƒ½è¿‡æ²³çš„ç»“è®ºï¼Œæ‰€ä»¥æ— éœ€éå†æ‰€æœ‰è·¯å¾„ï¼ˆé™¤éæ‰€æœ‰è·¯å¾„éƒ½ä¸èƒ½åˆ°è¾¾ï¼‰ã€‚ ä¸ºäº†å°½å¿«åœ°è§£å†³é—®é¢˜ï¼Œå¾ˆæ˜æ˜¾æ˜¯ç”¨æ·±åº¦éå†çš„ï¼Œå½“å¾—åˆ°ä¸€æ¡è·¯å¾„åï¼Œé©¬ä¸Šè¿”å›trueèŠ‚çœæ—¶é—´ã€‚æ‰€ä»¥ä½¿ç”¨é€’å½’çš„æ–¹å¼ï¼Œéå†æ‰€æœ‰çŠ¶æ€ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233#include&lt;vector&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; stoness = stones; return cross(stoness.begin(),0); &#125; bool cross(vector&lt;int&gt;::iterator start, int dis) &#123; if(start == stoness.end()-1) &#123; return true; &#125; for(int i = dis - 1; i &lt;= dis+1; i++) &#123; vector&lt;int&gt;::iterator it = find(start+1,stoness.end(),i+*start); if(it != stoness.end())&#123; if(cross(it,i)) &#123; return true; &#125; &#125; else &#123; continue; &#125; &#125; return false; &#125;private: vector&lt;int&gt;stoness;&#125;; ç»“æœä¸åæ€ åœ¨è¿‡äº†exampleåï¼Œæäº¤çš„æ£€æµ‹è¶…æ—¶äº†ï¼Œä¾‹å­æ˜¯[1â€¦998,99999999],è¿™ä¸ªæç«¯çš„ä¾‹å­å±•ç¤ºäº†è¿™ä¸ªç®—æ³•çš„å¼±ç‚¹ï¼Œæ²¡æœ‰æ ¹æ®æœç´¢å¾—çš„ä¿¡æ¯åŠ å¿«é€Ÿåº¦ï¼Œæ¯æ¬¡éƒ½æœç´¢åˆ°äº†998è¿™ä¸ªèŠ‚ç‚¹ï¼Œä½†ç”±äºæœ€åä¸€ä¸ªç‚¹ä¸å¯åˆ°è¾¾ï¼Œæ‰€ä»¥éƒ½åœ¨æœ€åä¸€æ­¥ç»ˆæ­¢ï¼Œæµªè´¹äº†å¤§é‡çš„æ—¶é—´ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é‡‡å–ä¸€ç§æªæ–½åŠæ—¶æ­¢æŸã€‚ ç¬¬äºŒæ¬¡è§£é¢˜æ€è·¯ é‡‡ç”¨éå†è·¯å¾„æ ‘æ˜¯æ²¡æœ‰é”™çš„ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦éªŒè¯æ¯ä¸€æ¡è·¯å¾„æ˜¯å¦èƒ½é€šå¾€æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½†æˆ‘ä»¬ä¸èƒ½é‡å¤åˆ¤æ–­åŒä¸€ä¸ªçŠ¶æ€å¤šæ¬¡ï¼Œå› ä¸ºæ¯æ¡è·¯å¾„ä¸­æœ‰ç€è®¸å¤šç›¸åŒçš„çŠ¶æ€ï¼Œå³è¾¾åˆ°ç‚¹ç›¸åŒï¼Œä¸”ä¸‹ä¸€æ­¥çš„è·³è¶ŠèŒƒå›´ç›¸åŒï¼Œå¦‚æœæˆ‘ä»¬åœ¨ä¸€æ¡è·¯å¾„ä¸­å·²ç»å¾—çŸ¥è¯¥çŠ¶æ€æ˜¯å¦èƒ½è¾¾åˆ°ç»ˆç‚¹ï¼Œå°±å¯ä»¥åœ¨å…¶å®ƒè·¯å¾„ä¸­å¼•ç”¨è¿›è¡Œå¿«é€Ÿåˆ¤æ–­ã€‚å°±æ˜¯å¦‚ä¸€ä¸ªèŠ‚ç‚¹ä¸é€šï¼Œåˆ™ç»è¿‡è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„éƒ½ä¸é€šã€‚ å…·ä½“æ–¹æ³•æ˜¯ç»´æŠ¤ä¸€ä¸ªå“ˆå¸Œè¡¨ä¿å­˜çŠ¶æ€çš„å¯è¡Œæ€§ï¼Œå› ä¸ºä¸€ä¸ªçŠ¶æ€æœ‰ä¸¤ä¸ªå±æ€§ï¼Œä¸€æ˜¯ç‚¹çš„ä½ç½®ï¼ŒäºŒæ˜¯ä¸Šä¸€æ­¥è·³è¶Šè·ç¦»ï¼Œå› ä¸ºçŸ³å¤´æ•°é‡æœ‰é™ï¼Œå¯ä»¥é€šè¿‡å·¦ç§»å–æˆ–ï¼Œå°†ä¸¤ä¸ªå€¼åˆå¹¶èµ·æ¥å¾—åˆ°ä¸€ä¸ªå”¯ä¸€çš„å€¼ï¼Œä»è€Œç¡®å®šä¸€ä¸ªå”¯ä¸€çš„çŠ¶æ€ï¼Œä¿å­˜è¯¥çŠ¶æ€æ˜¯å¦èƒ½è¾¾åˆ°ç»ˆç‚¹ã€‚ æ”¹è¿›ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839#include&lt;vector&gt;#include&lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;unordered_map&gt;using namespace std;class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; stoness = stones; return cross(stoness.begin(),0); &#125; bool cross(vector&lt;int&gt;::iterator start, int dis) &#123; if(start == stoness.end()-1) &#123; return true; &#125; int key = *start | dis&lt;&lt;11; if (status.count(key)) &#123; return status[key]; &#125; for(int i = dis + 1; i &gt;= dis-1; i--) &#123; vector&lt;int&gt;::iterator it = find(start+1,stoness.end(),i+*start); if(it != stoness.end())&#123; if(cross(it,i)) &#123; return status[key] = true; &#125; &#125; else &#123; continue; &#125; &#125; return status[key] = false;; &#125;private: vector&lt;int&gt;stoness; unordered_map&lt;int, bool&gt; status;&#125;; Note åœ¨æŸ¥è¯¢ä¸‹ä¸€ä¸ªè·³è¶Šç‚¹æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¾ªç¯æ¥å¯»æ‰¾ï¼Œä½†æˆ‘è§‰å¾—å¦‚æœè·³è¶Šè·ç¦»å¾ˆå¤§ï¼Œé‚£ä¹ˆå°±è¦éå†å¾ˆå¤šä¸ªä½ç½®ï¼Œå› æ­¤ä½¿ç”¨findç›´æ¥åœ¨vectorä¸­å¯»æ‰¾å¯¹åº”k-1ï¼Œkï¼Œk+1è·ç¦»çš„ç‚¹ä¼šæ›´åŠ å¿«ã€‚ åœ¨çœ‹äº†ä¸€ä¸‹åˆ«äººçš„åšæ³•ä¸­ï¼Œå‘ç°å¯ä»¥å…ˆåœ¨ä¸¤ä¸ªç‚¹ä¹‹åï¼Œåˆ¤æ–­æ˜¯å¦åä¸€ä¸ªç‚¹æ˜¯å‰ä¸€ä¸ªç‚¹çš„ä¸¤å€è¿˜å¤šï¼Œå³stone[i]&gt;2*stone[i-1]ï¼Œè‹¥å­˜åœ¨è¿™ä¸€æƒ…å†µï¼Œé‚£ä¹ˆå¿…å®šä¸èƒ½åˆ°è¾¾ï¼Œå› ä¸ºé’è›™åœ¨2æ¬¡è·³è¶Šåï¼Œä¸å¯èƒ½è·³è¶Š2å€çš„è·ç¦»ï¼Œè€Œä¸”è¿™ä¸ªæ•°ç»„åˆæ˜¯å‡åºçš„ï¼Œæ‰€ä»¥ä¸å¯é€¾è¶Šã€‚å¯ä»¥å»æ‰å¾ˆå¤šæç«¯æƒ…å†µã€‚ çœ‹äº†ä¸€ä¸‹é¢˜ç›®çš„è¯„è®ºï¼Œæœ‰ä¸€ä¸ªè¯„è®ºè¯´ä»æ­¥æ•°å¤§çš„å¼€å§‹éå†ä¼šæ›´å¿«å¾—åˆ°ç­”æ¡ˆï¼Œæƒ³äº†ä¸€ä¸‹ä¼¼ä¹æ˜¯è¿™æ ·çš„ï¼Œå› ä½è¾ƒå°çš„æ­¥æ•°æœ€ç»ˆå¾ˆæœ‰å¯èƒ½èµ°åˆ°å¤§æ­¥æ•°çš„çŠ¶æ€ï¼Œä¸­é—´å¤šå‡ºäº†å¾ˆå¤šä¸å¿…è¦çš„çŠ¶æ€ï¼Œæ”¹æˆiâ€“åï¼Œä»24msæå‡åˆ°äº†16msï¼Œæ„Ÿè§‰æ”¹å–„å¾ˆå®¢è§‚ã€‚å±…ç„¶èƒ½åˆ°95.46%äº†ã€‚ Frog Jump_test æ€»ç»“ è¿™ä¸ªé¢˜ç›®çš„å…³é”®ä¹‹å¤„åœ¨äºå¦‚ä½•åˆ©ç”¨å·²çŸ¥çš„ä¿¡æ¯è¿›è¡Œæœç´¢ï¼Œè€Œä¸æ˜¯é‡‡ç”¨ç›²ç›®æœç´¢çš„æ–¹å¼ï¼Œåœ¨æœç´¢è¿‡ç¨‹ä¸­ï¼Œå‘ç°ä¸€ä¸ªç‚¹ä¸é€šåˆ™å°†ä¹‹åçš„è·¯å¾„å°æ‰ï¼Œå¯¹ä¿¡æ¯çš„å¤ç”¨ï¼Œæå¤§åŠ å¿«ç®—æ³•çš„é€Ÿåº¦ï¼Œå¦å¤–ä¸€äº›é¡ºåºçš„é€‰æ‹©ä¹Ÿå¾ˆæœ‰å¯èƒ½å½±å“é€Ÿåº¦ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 297. Serialize and Deserialize Binary Tree","date":"2018-10-14T08:38:00.000Z","path":"2018/10/14/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/","text":"297. Serialize and Deserialize Binary Tree week6 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example: You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5 as \"[1,2,3,null,null,4,5]\" Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. é¢˜ç›®åˆ†æ é¢˜ç›®çš„æ„æ€æ˜¯å°†ä¸€æ£µæ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œè€Œä¸”åºåˆ—åŒ–åçš„æ ‘èƒ½å¤Ÿç»è¿‡ååºåˆ—åŒ–å˜ä¸ºåŸæ¥çš„æ ‘ç»“æ„ã€‚åºåˆ—åŒ–çš„æ„æ€æ˜¯å°†çŠ¶æ€ä¿¡æ¯è½¬åŒ–ä¸ºå¯ä»¥å­˜å‚¨å’Œä¼ è¾“çš„å½¢å¼ï¼Œè¿™åœ¨å¾ˆå¤šåœºåˆéƒ½èƒ½å¤Ÿç”¨åˆ°ï¼Œå¯ä»¥ä½¿è‡ªå®šä¹‰å¯¹è±¡æŒä¹…åŒ–ï¼Œæ–¹ä¾¿ä¼ è¾“å¯¹è±¡ï¼Œä»¥åŠä¾¿äºç¨‹åºç»´æŠ¤ç­‰ç­‰ã€‚ è§£é¢˜æ€è·¯ é¢˜ç›®å·²ç»ç»™å‡ºäº†LeetCodeæ‰€ç”¨çš„äºŒå‰æ ‘çš„åºåˆ—åŒ–çš„å½¢å¼ï¼Œå³å°†äºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹çš„å€¼å­˜åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ï¼Œç”¨æ ‡ç‚¹ç¬¦å·éš”å¼€ã€‚è§‚å¯Ÿå…¶é¡ºåºå¯ä»¥å‘ç°æ˜¯ä½¿ç”¨åˆ†å±‚æ–¹å¼æ¥æ„é€ çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨åˆ†å±‚éå†çš„æ–¹å¼æ¥æ„é€ è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åå†è¿˜åŸã€‚ ä½¿ç”¨åˆ†å±‚éå†ï¼Œæ„é€ ä¸€ä¸ªé˜Ÿåˆ—å­˜å‚¨éå†çš„èŠ‚ç‚¹å¹¶å°†å­èŠ‚ç‚¹æ”¾åœ¨é˜Ÿåˆ—ä¸­ï¼Œä»è€Œé€å±‚éå†ï¼Œæ„é€ å­—ç¬¦ä¸²ï¼Œæ³¨æ„ä¹Ÿè¦æŠŠç©ºèŠ‚ç‚¹æ”¾è¿›å»ï¼Œå¦åˆ™å°†æ— æ³•è¿˜åŸä¸ºåŸæ¥çš„æ ‘ã€‚ å¾—åˆ°å­—ç¬¦ä¸²å¹¶ä»¥â€œï¼Œâ€ä¸ºåˆ†å‰²ç‚¹åˆ†å‰²æˆä¸åŒçš„å­—ç¬¦ä¸²èŠ‚ç‚¹ï¼Œç„¶åä½¿ç”¨é˜Ÿåˆ—æ„é€ å›åŸæ¥çš„æ ‘ã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */#include &lt;string&gt;#include &lt;queue&gt;using namespace std;class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string sertree; queue&lt;TreeNode*&gt; queue; queue.push(root); while(!queue.empty())&#123; TreeNode* node = queue.front(); queue.pop(); if(sertree.length()&gt;0) &#123; sertree += \",\"; &#125; if(node == nullptr) &#123; sertree += \"null\"; &#125; else &#123; sertree += std::to_string(node-&gt;val); queue.push(node-&gt;left); queue.push(node-&gt;right); &#125; &#125; return sertree; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if(data == \"null\") &#123; return nullptr; &#125; vector&lt;string&gt; treeNodes = split(data,\",\"); TreeNode* root = new TreeNode(atoi(treeNodes[0].c_str())); queue&lt;TreeNode*&gt; queue; queue.push(root); for(int i = 1; i &lt; treeNodes.size(); i+=2)&#123; TreeNode* node = queue.front(); queue.pop(); if(treeNodes[i] != \"null\")&#123; TreeNode* left = new TreeNode(atoi(treeNodes[i].c_str())); node-&gt;left = left; queue.push(left); &#125; if(treeNodes[i+1] != \"null\")&#123; TreeNode* right = new TreeNode(atoi(treeNodes[i+1].c_str())); node-&gt;right = right; queue.push(right); &#125; &#125; return root; &#125; vector&lt;string&gt; split(const string&amp; str, const string&amp; delim) &#123; vector&lt;string&gt; res; if(\"\" == str) return res; //å…ˆå°†è¦åˆ‡å‰²çš„å­—ç¬¦ä¸²ä»stringç±»å‹è½¬æ¢ä¸ºchar*ç±»å‹ char * strs = new char[str.length() + 1] ; strcpy(strs, str.c_str()); char * d = new char[delim.length() + 1]; strcpy(d, delim.c_str()); char *p = strtok(strs, d); while(p) &#123; string s = p; //åˆ†å‰²å¾—åˆ°çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºstringç±»å‹ res.push_back(s); //å­˜å…¥ç»“æœæ•°ç»„ p = strtok(NULL, d); &#125; return res; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); Note æ³¨æ„cä¸­çš„stringä¸­æ²¡æœ‰splitè¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥è¦è‡ªå·±å†™ä¸€ä¸ªsplitå‡½æ•°ï¼Œä½¿ç”¨cé‡Œçš„strtokæ–¹æ³•ï¼Œå…ˆå°†å­—ç¬¦ä¸²è½¬åŒ–æˆCharæ•°ç»„ç±»å‹ï¼Œï¼ˆæ³¨æ„char*æœ€åæœ‰ä¸€ä¸ªç»ˆæ­¢ç¬¦ï¼Œlength+1ï¼‰ï¼Œç„¶åè°ƒç”¨è¿™ä¸ªæ–¹æ³•æ¥å¤„ç†charæ•°ç»„ï¼Œé€šè¿‡å¾ªç¯è¿›è¡Œé€æ­¥åˆ†å‰²ï¼Œå†å˜æˆstringï¼Œæœ€åä¼ å‡ºç»“æœvector; ååºåˆ—åŒ–ä¸ºæ ‘ç»“æ„æ—¶ï¼Œéœ€è¦æ³¨æ„è¦å»é™¤ç©ºèŠ‚ç‚¹ã€‚å¦åˆ™å°†ä¼šå‡ºç°è®¿é—®ç©ºèŠ‚ç‚¹çš„é”™è¯¯ï¼Œå¦å¤–å› ä¸ºå­˜æ”¾äº†nullï¼Œæ‰€ä»¥æ¯ä¸€æ¬¡å¯ä»¥åŒæ—¶è®¿é—®å·¦å³ä¸¤ä¸ªèŠ‚ç‚¹ã€‚ é™¤äº†ä½¿ç”¨åˆ†å±‚åºåˆ—åŒ–ä¹‹å¤–ï¼Œè¿˜æœ‰è®¸å¤šæ–¹æ³•ï¼Œæ¯”å¦‚ä½¿ç”¨æ·±åº¦+é€’å½’ï¼Œå¹¿åº¦éå†ä¹Ÿå¯ä»¥ï¼Œåªè¦èƒ½å¤Ÿåšåˆ°ååºåˆ—åŒ–ä»è½¬åŒ–ä¸ºåŸæ¥çš„æ ‘ç»“æ„å³å¯ã€‚ æ€»ç»“ åœ¨è¿™ä¸ªé¢˜ç›®ä¸­ï¼Œæˆ‘å‘ç°JAVAå’ŒCå…¶å®å¾ˆå¤§åŒºåˆ«çš„ï¼Œå†™å¤šäº†JAVAä¹‹åï¼Œå‘ç°è®¸å¤šæ–¹æ³•éƒ½åœ¨cæ²¡æœ‰æä¾›ï¼Œæ¯”å¦‚splitï¼Œè¿˜æœ‰è®¸å¤šå¾ˆæ–¹ä¾¿ä½¿ç”¨çš„Likedlistç­‰ç­‰æ•°æ®ç»“æ„ã€‚æ‰€ä»¥åœ¨JAVAä¸­è®¸å¤šåŒ…è£…çš„æ–¹æ³•è¿˜æ˜¯æŒºå¥½ç”¨çš„ï¼Œä»¥å‰è¿˜è§‰å¾—å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯ç°åœ¨å‘ç°åœ¨åº”ç”¨ä¸Šçš„ä¾¿åˆ©æ€§ä¸Šå·®è·æŒºå¤§çš„ï¼Œæ‰€ä»¥é‡åˆ°é—®é¢˜å¯ä»¥å…ˆä½¿ç”¨JAVAæ¥å®Œæˆä¸€ä¸‹ï¼Œç¡®å®šè§£å†³çš„æ–¹æ³•ï¼Œç„¶åå†ä½¿ç”¨C++æ¥å®ç°ã€‚ çœ‹äº†ä¸€ä¸‹é™¤æ­¤ä¹‹å¤–æœ‰äººä½¿ç”¨map&lt;long,TreeNode*&gt;æ¥è¿›è¡Œå­˜å‚¨ï¼Œç›´æ¥å·é¸¡ä½¿ç”¨å…¨å±€å˜é‡å­˜å‚¨çŠ¶æ€ã€‚ã€‚ã€‚ä¸ç®—æ˜¯åºåˆ—åŒ–ã€‚è€Œä¸”é¢˜ç›®å·²ç»æ ‡æ˜äº†ä¸å¯ç”¨å­˜å‚¨çŠ¶æ€çš„åšæ³•äº†ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 679. 24 Game","date":"2018-10-07T12:49:00.000Z","path":"2018/10/07/LeetCode-679-24-Game/","text":"24 Game week5 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24. Example1: Input: [4, 1, 8, 7] Output: True Explanation: (8-4) * (7-1) = 24 Example2: Input: [1, 2, 1, 2] Output: False Note: 1.The division operator / represents real division, not integer division. For example, 4 / (1 - 2/3) = 12. 2. Every operation done is between two numbers. In particular, we cannot use - as a unary operator. For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed. 3. You cannot concatenate numbers together. For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12. é¢˜ç›®åˆ†æ è¿™é“é¢˜ç›®çš„æ„æ€å¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯è¦è§£å†³24ç‚¹çš„é—®é¢˜ï¼Œéšæœºç»™å‡º4ä¸ªæ•°ï¼Œä»…èƒ½ç”¨å››åˆ™è¿ç®—ï¼Œè‹¥å¾—åˆ°24ç‚¹åˆ™è¾“å‡ºæ­£ç¡®ï¼Œå¦åˆ™è¾“å‡ºé”™è¯¯ã€‚ è§£é¢˜æ€è·¯ è§£å†³è¿™é“é¢˜ä¸€å¼€å§‹æ˜¯ä½¿ç”¨ç©·ä¸¾æ³•ï¼Œå°†æ‰€æœ‰çš„å¯èƒ½éƒ½åˆ—ä¸¾å‡ºæ¥ï¼Œç„¶åè¿›è¡Œåˆ¤æ–­ï¼Œä½†æ¯ä¸€æ¬¡è¿ç®—åªèƒ½å‡å°‘ä¸€ä¸ªæ•°ï¼Œè€Œä¸€å¼€å§‹æœ‰4ä¸ªæ•°ï¼Œ4ä¸ªè¿ç®—æ³•åˆ™ï¼Œè€Œå››åˆ™è¿ç®—ä¸­ï¼Œä¹˜å’ŒåŠ æ˜¯å’Œä¸¤ä¸ªæ•°é¡ºåºæ— å…³çš„ï¼Œé‚£ä¹ˆç»“æœæœ‰$$C2_4*6*C2_36C^2_2*6 = 3888$$ ç§å¯èƒ½ï¼Œæœ‰ç‚¹å¤šï¼Œä¸å¯èƒ½ç”¨ä»£ç éƒ½åˆ—å‡ºæ¥ã€‚ æ‰€ä»¥æ¥ä¸‹æ¥è€ƒè™‘åˆ©ç”¨é€’å½’çš„æ–¹å¼ï¼Œå°†æ¯ä¸€ç§æ–¹æ³•éƒ½éå†ä¸€éï¼Œç±»ä¼¼äºæ·±åº¦æœç´¢çš„æ–¹æ³•ï¼Œæ„æˆä¸€æ£µæ ‘ï¼Œæ ¹ä¸º4ä¸ªæ•°ï¼Œæ¯ä¸ªåˆ†æ”¯ä»£è¡¨ä¸€æ¬¡è¿ç®—ï¼Œå…¶å­èŠ‚ç‚¹æ•°çš„ä¸ªæ•°-1ï¼Œå› æ­¤æ ‘çš„é«˜åº¦ä¸º4ï¼Œç”¨æ·±åº¦éå†çš„åŸå› æ˜¯æˆ‘ä»¬åªéœ€è¦æŠŠè¿™ä¸ª24ç‚¹æœ‰æ— è§£è¾“å‡ºå°±å¯ä»¥äº†ï¼Œä¸éœ€è¦è¾“å‡ºè§£ç”šè‡³æ‰€æœ‰çš„è§£ï¼Œæ‰€ä»¥æ¯æ¬¡éå†éƒ½è¦è¾¾åˆ°é«˜åº¦4ï¼Œä»¥ä¾¿æœ€å¿«å¾—åˆ°ä¸€ä¸ªè§£ã€‚ é‡‡ç”¨é€’å½’çš„æ–¹å¼èƒ½å¤Ÿæ›´å¥½çš„éå†ï¼Œå½“ä¸€ä¸ªè§£ä¸ç¬¦åˆæ—¶ï¼Œé©¬ä¸Šé€€å›ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªè§£ï¼Œè¿™é‡Œä½¿ç”¨vectorå­˜å‚¨å¾—åˆ°çš„è§£ï¼Œå½“ä¸ç¬¦åˆæ—¶ï¼Œå¼¹å‡ºå¾—åˆ°çš„è¿ç®—æ•°ï¼Œå›åˆ°ä¸Šä¸€çŠ¶æ€ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123;public: bool judgePoint24(vector&lt;int&gt;&amp; nums) &#123; vector&lt;double&gt; dnums; for(int val:nums) &#123; dnums.push_back((double)val); &#125; return dfs(dnums); &#125; bool dfs(vector&lt;double&gt;&amp; nums) &#123; if(nums.size() == 0) &#123; return false; &#125; else if(nums.size() == 1) &#123; return abs(nums[0] - 24) &lt; 1e-6; &#125; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; size; j++) &#123; if(i == j) &#123; continue; &#125; vector&lt;double&gt;card; for(int k = 0;k &lt; size; k++) &#123; if(k != i &amp;&amp; k != j) &#123; card.push_back(nums[k]); &#125; &#125; for(int l = 0; l &lt; 4; l++) &#123; if(l == 0) &#123; card.push_back(nums[i]+nums[j]); &#125; else if(l == 1) &#123; card.push_back(nums[i]*nums[j]); &#125; else if(l == 2) &#123; card.push_back(nums[i]-nums[j]); &#125; else if(l == 3 &amp;&amp; nums[j]!= 0) &#123; card.push_back(nums[i]/nums[j]); &#125; if(dfs(card)) &#123; return true; &#125; card.pop_back(); &#125; &#125; &#125; return false; &#125;&#125;; Note å› ä¸ºæ‰€ç»™çš„æ•°çš„ç±»å‹æ˜¯intï¼Œå› æ­¤åœ¨è¿ç®—æ—¶è¦å°†å…¶è½¬æˆdoubleç±»å‹æ–¹ä¾¿è¿›è¡Œä¹˜é™¤è¿ç®—ï¼Œå¦åˆ™ä¼šå‡ºç°è¾ƒå¤§è¯¯å·®ï¼Œå¹¶ä¸”åˆ¤æ–­æ˜¯å¦ä¸º24ç‚¹æ—¶å› è®¡ç®—æœºçš„è¿ç®—å¯èƒ½å­˜åœ¨è¯¯å·®ï¼Œæ‰€ä»¥è¦æ ¹æ®å…¶å’Œ24ç‚¹çš„è¯¯å·®å°äºä¸€å®šå€¼æ¥åˆ¤æ–­ã€‚ å› ä¸ºåœ¨åŠ å‡ä¹˜é™¤ä¸­ï¼ŒåŠ å’Œä¹˜å¯¹äºæ•°ä½œä¸ºè¢«åŠ /ä¹˜æ•°å’ŒåŠ /ä¹˜æ•°çš„ç»“æœæ˜¯æ— å½±å“çš„ï¼Œå› æ­¤ï¼Œå¯ä»¥è·³è¿‡2æ¬¡è¿ç®—ï¼Œè¿™æ ·ç›¸å½“äºæ¯ä¸ªèŠ‚ç‚¹åŸæœ¬8ä¸ªå­èŠ‚ç‚¹ç¼©å‡ä¸º6ä¸ªå­èŠ‚ç‚¹ï¼Œå¤§å¤§å‡å°‘å…¶åˆ†æ”¯ï¼Œä¸€å¼€å§‹ä»¥ä¸ºæ²¡å°‘å¤šå°‘ï¼Œä½†æ˜¯ç”±äºæ ‘é«˜ä¸º4ï¼Œç®—å‡ºçš„è§£èƒ½å°‘3/4ï¼Œæå¤§å‡å°‘æ—¶é—´ã€‚ åŠ å‡ä¹˜é™¤çš„é¡ºåºå¯ä»¥è°ƒè½¬ï¼Œä¹Ÿå¯ä»¥æ˜¯å…ˆåšåŠ è¿ç®—ä¸€ç›´åšåˆ°å¤´ï¼Œå†åšå…¶å®ƒè¿ç®—ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯ä¸ªäººè§‰å¾—è¿ç®—æ··æ­å¯èƒ½ä¼šåŠ å¿«å¾—åˆ°è§£çš„é€Ÿåº¦ï¼Œå³å¾—åˆ°è§£çš„æ¦‚ç‡ä¼šå¤§ä¸€äº›ï¼Œå•ä¸€è¿›è¡Œè¿ç®—å¾ˆéš¾å¾—åˆ°24ç‚¹ã€‚åˆç”±äºå…¶è¿ç®—ç»“æœä¸ªæ•°å¹¶ä¸å¤šï¼Œæ‰€ä»¥æ„Ÿè§‰ä½¿ç”¨å¯å‘å¼æœç´¢å¹¶æ²¡æœ‰å¤ªå¤§æ”¹è¿›ï¼Œåˆ¤æ–­æ—¶é—´å¯èƒ½ä½¿æœç´¢æ—¶é—´å˜å¾—æ›´å¤šã€‚ æ€»ç»“ æ€è·¯ä¸»è¦æ˜¯æ¥æºäºé¢˜ç›®å†™äº†ä¸€ä¸ªtagä¸ºâ€œdepth-first searchâ€è®©æˆ‘æœ‰äº†ä¸€ç‚¹æ€è·¯ï¼Œåšè¿™ä¸€äº›åˆ¤æ–­ç­‰é¢˜ç›®ï¼Œè‹¥æ˜¯è¦è¿›è¡Œæ‰€æœ‰ç»“æœçš„éå†ï¼Œé‚£ä¹ˆæœ€å¥½çš„æ–¹æ³•å°±æ˜¯è¿›è¡Œæœç´¢ï¼Œæœç´¢ä¸»è¦å°±æ˜¯ç”¨åˆ°äº†æ ‘çš„éå†ï¼Œå³éå†çŠ¶æ€ã€‚å¦‚æœçŠ¶æ€æ•°è¿‡å¤šï¼Œé‚£ä¹ˆä½¿ç”¨å¯å‘å¼æœç´¢è¦æ¯”ç›²ç›®æœç´¢æ›´å¥½ï¼Œè€Œç›²ç›®æœç´¢ä¹Ÿè¦æ ¹æ®ç›®çš„æ¥ç¡®å®šï¼Œå¯å‘å¼æœç´¢çš„éš¾ç‚¹å°±åœ¨äºè°ƒå‚ï¼Œç¡®å®šä¸€ä¸ªæœç´¢æ–¹å‘ï¼Œè€Œè¿™é“é¢˜å› æ–¹å‘éš¾ä»¥ç¡®å®šï¼Œè€ŒçŠ¶æ€æ•°ä¸å¤šï¼Œå› æ­¤æ‰é‡‡ç”¨æ·±åº¦æœç´¢ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 124. Binary Tree Maximum Path Sum","date":"2018-09-30T02:17:00.000Z","path":"2018/09/30/LeetCode-124-Binary-Tree-Maximum-Path-Sum/","text":"Binary Tree Maximum Path Sum week4 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example2: Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42 é¢˜ç›®åˆ†æ è¿™é“é¢˜ç›®è¦æ±‚æ‰¾å‡ºä¸€é¢—äºŒå‰æ ‘ä¸­çš„å¾—åˆ°æœ€å¤§æ•°ä¹‹å’Œçš„ä¸€æ¡è·¯å¾„ï¼Œè·¯å¾„ä¸­çš„å¤´å’Œå°¾å¯ä»¥æ˜¯äºŒå‰æ ‘ä¸­çš„ä»»æ„ä¸€èŠ‚ç‚¹ã€‚è¿™ä¹Ÿå°±æ˜¯è¯´é™¤äº†å¯ä»¥ç»è¿‡æ ¹èŠ‚ç‚¹å¤–ï¼Œè¿˜å¯ä»¥æ˜¯äºŒå‰æ ‘é‡Œä»»æ„å­æ ‘ï¼Œåªè¦å¾—åˆ°çš„å’Œä¸ºæœ€å¤§ã€‚ è§£é¢˜æ€è·¯ é¦–å…ˆæƒ³åˆ°çš„æ˜¯ç”¨é€’å½’çš„ç®—æ³•ï¼Œæ¥ç®—å‡ºæ¯ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹æ‰€å¾—åˆ°çš„æœ€å¤§è·¯å¾„å’Œï¼Œè¿™å’Œä¹¦ä¸Šç¬¬å››ç« çš„æŸé“é¢˜ç›®æœ‰ç‚¹ç›¸åƒï¼šå·²çŸ¥ä¸¤é¡¶ç‚¹ï¼Œæ±‚å‡ºä¸¤ä¸ªé¡¶ç‚¹å­˜åœ¨å¤šå°‘æ¡è·¯å¾„ã€‚å½“æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨é€’å½’æ–¹å¼åˆ†åˆ«æ±‚å‡ºä¸Šä¸€å±‚åˆ°ä¸‹ä¸€å±‚èŠ‚ç‚¹æœ‰å¤šå°‘æ¡è·¯å¾„ï¼Œé€æ­¥è®¡ç®—å‡ºåˆ°è¾¾æ¯ä¸€å±‚çš„è·¯å¾„ï¼Œæœ€åå¾—åˆ°æ€»çš„è·¯å¾„æ•°ã€‚ è¿™é“é¢˜ç›®ä¹Ÿæ˜¯è¿™æ ·ï¼Œå­æ ‘çš„æœ€å¤§è·¯å¾„å’Œå¯ä»¥æ˜¯å·¦å­æ ‘+æ ¹+å³å­æ ‘ç­‰ç­‰ï¼Œä½†å…¶ä½œä¸ºä¸Šä¸€å±‚çš„å­èŠ‚ç‚¹åªèƒ½æ˜¯å·¦å­æ ‘/å³å­æ ‘+æ ¹ã€‚å› æ­¤æˆ‘ä»¬åˆ¤æ–­é•¿åº¦å’Œè¿”å›åˆ°ä¸Šä¸€å±‚çš„å€¼æ˜¯ä¸ä¸€æ ·çš„ã€‚å³maxNum = max(leftNum + rightNum + node-&gt;val,maxNum);(è‹¥å·¦å³å­æ ‘&lt;0ï¼Œåˆ™è®¾å…¶ä¸º0)å’Œè¿”å›çš„å€¼return node-&gt;val + sumNum; ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243/* * * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: int maxNum; int maxPathSum(TreeNode* root) &#123; if(root != nullptr) &#123; maxNum = root-&gt;val; &#125; sumPath(root); return maxNum; &#125; int sumPath(TreeNode * node) &#123; if(node == nullptr) &#123; return 0; &#125; int leftNum = sumPath(node-&gt;left);//æ±‚å·¦å³å­èŠ‚ç‚¹çš„æœ€å¤§è·¯å¾„å’Œ int rightNum = sumPath(node-&gt;right); if(leftNum &lt; 0) &#123; leftNum = 0; &#125; if(rightNum &lt; 0) &#123; rightNum = 0; &#125; int sumNum = max(leftNum,rightNum); maxNum = max(leftNum + rightNum + node-&gt;val,maxNum);//æ¯ä¸€æ¬¡å’ŒåŸæœ¬çš„å€¼ä½œæ¯”è¾ƒ return node-&gt;val + sumNum; &#125;&#125;; Note æœ‰å¯èƒ½å­˜åœ¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸€å¼€å§‹æœ€å¤§å’Œè®¾ä¸ºæ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä¹Ÿå¯ä»¥è®¾ç½®æˆINT_MINï¼Œå› ä¸ºå¯èƒ½æœ€ç»ˆçš„å€¼æ˜¯è´Ÿæ•°ã€‚ å› ä¸ºä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹çš„å°±æ˜¯è·¯å¾„æœ€å¤§å’Œï¼Œè€Œä¸”æ¯ä¸€é¢—å­æ ‘éƒ½æœ‰å¯èƒ½æ˜¯ç›®æ ‡æ ‘æˆ–è€…ä¸€ä¸ªç‰¹åˆ«å¤§çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ¯æ¬¡é€’å½’éƒ½è¦è¿›è¡Œä¸€æ¬¡æ¯”è¾ƒï¼Œä»¥æ±‚å¾—æœ€å¤§çš„å€¼ã€‚ åšå®Œä¹‹åå‘ç°ä»£ç è¿è¡Œå¥½åƒå¾ˆæ…¢ï¼Œæ¯”è¾ƒäº†ä¸€ä¸‹å’Œå¤§ä½¬çš„ä»£ç ï¼Œå‘ç°è¿˜æ˜¯å†™çš„å¤ªå¤æ‚äº†ä¸€ç‚¹ï¼Œæœ‰ä¸€äº›åˆ¤æ–­æ ¹æœ¬æ˜¯ä¸å¿…è¦çš„ï¼Œæ¯”å¦‚åˆ¤æ–­æ˜¯å¦&lt;0ç­‰ï¼Œç›´æ¥ç”¨maxå–æœ€å¤§çš„å°±å¯ä»¥äº†ï¼Œå› ä¸ºè´Ÿæ•°ä¸æ˜¯ä¸åˆæ³•çš„ï¼Œä¸ä¼šäº§ç”Ÿä»€ä¹ˆé€»è¾‘é”™è¯¯ã€‚ æ­¤å¤–å‘ç°å¤§ä½¬çš„ä»£ç ä¸­å†™äº†è¿™ä¹ˆä¸€å¥é€Ÿåº¦çœ‹èµ·æ¥æ¯”æˆ‘çš„å¿«ä¸å°‘ã€‚ã€‚ã€‚åœ¨ç½‘ä¸ŠæŸ¥äº†ä¸‹ä¹‹åä¼¼ä¹æ˜¯cinã€coutæ•ˆç‡ä½çš„åŸå› æ˜¯è¦æŠŠä¸œè¥¿è¾“å…¥åˆ°ç¼“å†²åŒºåœ¨è¿›è¡Œè¾“å…¥è¾“å‡ºï¼Œè¿™ä¸€å¥è¯­å¥å¯ä»¥å–æ¶ˆå…¶ç¼“å†²ï¼Œä½¿å¾—å’Œscanfã€printfçš„æ•ˆç‡å·®ä¸å¤šã€‚ã€‚è¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆä»¥å‰æœ‰æ—¶å€™ç”¨cinå’Œcoutä¼šè¶…æ—¶ï¼Œè€Œç”¨scanfã€printfä¸ä¼šã€‚ 1static int fast = []() &#123;ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); return 0; &#125;(); é™„ä¸Šå¤§ä½¬ç®€æ´çš„ä»£ç ã€‚ã€‚ä½†æ„Ÿè§‰é˜…è¯»ä¸Šå¯èƒ½å¹¶ä¸ä¼šå¾ˆå¿«ï¼Œå¯èƒ½æœ‰æ—¶å€™éœ€è¦åœ¨ç®€æ´å’Œæ˜“æ‡‚ä¸­ä½œå‡ºå–èˆ 12345678910111213141516static int fast = []() &#123;ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); return 0; &#125;();class Solution &#123;public: int go(TreeNode* t, int&amp; Ans) &#123; //maxPathSum through t if (!t) return 0; int L = go(t-&gt;left, Ans), R = go(t-&gt;right, Ans), Ret = 0; Ret = max(t-&gt;val, t-&gt;val + max(L, R)); Ans = max(Ans, max(L + R + t-&gt;val, Ret)); return Ret; &#125; int maxPathSum(TreeNode* t) &#123; int Ans = INT_MIN; go(t, Ans); return Ans; &#125;&#125;;","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 145. Binary Tree Postorder Traversal","date":"2018-09-23T02:10:00.000Z","path":"2018/09/23/LeetCode-145-Binary-Tree-Postorder-Traversal/","text":"Binary Tree Postorder Traversal week3 éš¾åº¦ï¼šHard é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Given a binary tree, return the postorder traversal of its nodesâ€™ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? è§£é¢˜æ€è·¯ è¿™é“é¢˜ç›®å°±æ˜¯æ™®é€šçš„ååºéå†ï¼Œå³è®¿é—®ä¸€æ£µæ ‘å¯¹å…¶å­èŠ‚ç‚¹ä½¿ç”¨å·¦ï¼Œå³ï¼Œä¸­çš„é¡ºåºè¿›è¡Œè®¿é—®ï¼Œå…¶ä¸­æœ‰é€’å½’å’Œéå†çš„åšæ³•ã€‚ é€’å½’æ€è·¯ï¼š é€’å½’çš„åšæ³•å°±æ˜¯é‡‡ç”¨åˆ†è€Œæ²»ä¹‹çš„æ–¹æ³•ï¼Œå¯¹ä¸€æ£µæ ‘å‡åˆ’åˆ†æˆ3ä¸ªèŠ‚ç‚¹ï¼Œæ¯å½“åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå…ˆå¯¹å…¶å·¦èŠ‚ç‚¹é€’å½’ï¼Œå†åˆ°å³èŠ‚ç‚¹ï¼Œæœ€åæ’å…¥ä¸­èŠ‚ç‚¹åç»“æŸé€’å½’ï¼Œä»¥åŠå½“æ‰€åˆ°èŠ‚ç‚¹ä¸ºç©ºæ—¶ä¹Ÿç»“æŸé€’å½’ã€‚ éå†æ€è·¯ï¼š éå†çš„æ€è·¯å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ ˆæ¥å­˜å–éå†çš„èŠ‚ç‚¹ï¼Œå½“è®¿é—®å®Œå…¶ä¸­æ‰€æœ‰çš„å­èŠ‚ç‚¹æ—¶ï¼Œå†ä½¿å®ƒå‡ºæ ˆï¼Œå…¶ä¸­ä¹Ÿæ˜¯ç”¨äº†é€’å½’çš„æ€è·¯ï¼Œå› ä¸ºé€’å½’å°±æ˜¯é€šè¿‡æ ˆæ¥å®ç°çš„ã€‚ ä»£ç  é€’å½’æ€è·¯ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector &lt;int&gt; ans; if(root == nullptr) &#123; return ans; &#125; vector &lt;int&gt; leftans = postorderTraversal(root-&gt;left); vector &lt;int&gt; rightans = postorderTraversal(root-&gt;right); ans.insert(ans.end(),leftans.begin(),leftans.end()); ans.insert(ans.end(),rightans.begin(),rightans.end()); ans.insert(ans.end(),root-&gt;val); return ans; &#125;&#125;; éå†æ€è·¯ 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; stack&lt;TreeNode*&gt; s; s.push(root); TreeNode* pre = root; while (!s.empty()) &#123; TreeNode* p = s.top(); s.pop(); res.insert(res.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return res; &#125;&#125;; Note æŒ‰ç…§æ—¶é—´å¤æ‚åº¦æ¥ç®—éå†çš„åº”è¯¥æ¯”é€’å½’çš„è¦å¿«ï¼Œä½†åœ¨ç½‘é¡µä¸Šæ˜¾ç¤ºæ˜¯ä¸€æ ·çš„é€Ÿåº¦ï¼Œçœ‹äº†ä¸€ä¸‹æ¯”è¾ƒæ…¢çš„å°±æ˜¯ä¸€äº›äººå…ˆæ˜¯ç”¨äº†æ ˆæ¥å¤„ç†èŠ‚ç‚¹ï¼Œåˆ°æœ€åè®¿é—®å­èŠ‚ç‚¹çš„æ—¶å€™åˆç”¨å›é€’å½’çš„æ–¹æ³•äº†ï¼Œè¿™ç§æ˜¯å…¸å‹çš„æ²¡æœ‰ç†è§£å¥½stackçš„ç”¨æ³•ï¼Œå…¶å…ˆè¿›åå‡ºçš„æ€§è´¨å¯ä»¥è®©å­èŠ‚ç‚¹ä¹Ÿä½¿ç”¨stackæ¥è¿›è¡Œéå†ã€‚ æ­¤å¤–è¿˜æœ‰ä¸€ç§åšæ³•å°±æ˜¯ä½¿ç”¨å…ˆåºéå†åï¼Œå†è¿›è¡Œç¿»è½¬ä»è€Œå¾—åˆ°ååºéå†çš„ç»“æœã€‚ 1234567891011121314151617stack&lt;TreeNode*&gt; stack;stack.push(root);while (!stack.empty()) &#123; TreeNode* cur = stack.top(); stack.pop(); res.push_back(cur-&gt;val); if (cur-&gt;left != nullptr) &#123; stack.push(cur-&gt;left); &#125; if (cur-&gt;right != nullptr) &#123; stack.push(cur-&gt;right); &#125;&#125;reverse(res.begin(),res.end());return res;","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"[LeetCode] 765. Couples Holding Hands","date":"2018-09-15T09:11:00.000Z","path":"2018/09/15/LeetCode/","text":"Couples Holding Hands week 2 é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1). The couplesâ€™ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat. Example 1: Input: row = [0, 2, 1, 3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input: row = [3, 2, 0, 1] Output: 0 Explanation: All couples are already seated side by side. Note: len(row) is even and in the range of [4, 60].row is guaranteed to be a permutation of 0â€¦len(row)-1. é¢˜ç›®åˆ†æ è¿™ä¸ªé¢˜æ„ä¸ºæœ‰Nå¯¹æƒ…ä¾£ååœ¨2Nä¸ªåº§ä½ä¸Šï¼Œä½†æ˜¯ä»–ä»¬å¹¶ä¸æ˜¯ååœ¨ä¸€èµ·çš„ï¼Œè¦ä½¿å¾—æ¯ä¸€å¯¹éƒ½èƒ½å¹¶è‚©ååœ¨ä¸€èµ·ï¼Œè®¡ç®—æœ€å°‘çš„äº¤æ¢æ¬¡æ•°ï¼Œä¸€æ¬¡äº¤æ¢å¯ä»¥é€‰æ‹©ä»»æ„çš„ä¸¤ä¸ªäººã€‚ æƒ…ä¾£æŒ‰ç…§é¡ºåºç¼–å·ï¼Œå¹¶ä¸æ˜¯ç›¸è¿çš„éƒ½æ˜¯æƒ…ä¾£ï¼Œï¼ˆ0ï¼Œ1ï¼‰ï¼Œï¼ˆ2ï¼Œ3ï¼‰ç­‰ç­‰ã€‚ç”±æ­¤å¯çŸ¥ä¸€ä¸ªå¶æ•°çš„ä¸‹ä¸€ä¸ªå¥‡æ•°å¿…å®šæ˜¯å®ƒçš„å¦ä¸€åŠã€‚ è§£é¢˜æ€è·¯ è¿™é‡Œçš„äº¤æ¢æœ‰ä¸¤ç§å¯èƒ½ï¼š äº¤æ¢ä¸€æ¬¡åï¼Œæœ‰ä¸¤ç»„æƒ…ä¾£å®Œæˆé…å¯¹ã€‚ äº¤æ¢ä¸€æ¬¡åï¼Œä»…æœ‰ä¸€ç»„æƒ…ä¾£å®Œæˆé…å¯¹ï¼Œè€Œå¦ä¸€ä¸ªç­‰å¾…ç»§ç»­äº¤æ¢ã€‚ å¯çŸ¥å¦‚æœæ¯ä¸€æ¬¡éƒ½æ˜¯ç¬¬ä¸€ç§äº¤æ¢çš„è¯ï¼Œåˆ™äº¤æ¢æ¬¡æ•°ä¼šæ¯”ç¬¬äºŒç§è¦å°‘ï¼Œç¬¬ä¸€ç§ä¸ºæœ€ä½³äº¤æ¢ï¼Œå› æ­¤æ€ä¹ˆæ ·æ‰èƒ½è®©å…¶å…ˆå®Œæˆç¬¬ä¸€ç§åŒ¹é…å‘¢ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ï¼Œæ—¢ç„¶æ˜¯ç¬¬ä¸€ç§ï¼Œåˆ™ä»–ä»¬çš„æƒ…ä¾£æ˜¯äº¤å‰åçš„ï¼Œå› æ­¤è‹¥è¿™4ä¸ªäººä¸­æœ‰2ç»„æƒ…ä¾£ï¼Œåˆ™å…¶å’Œå…¶ä»–ç»„çš„æƒ…ä¾£å°±æ²¡æœ‰äº¤é›†ï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½•å…¶å®ƒç»„çš„æƒ…ä¾£å¦‚ä½•äº¤æ¢éƒ½ä¸ä¼šå½±å“åˆ°ä»–ä»¬ã€‚ï¼ˆè¿™é‡ŒæŒ‡äº¤æ¢éƒ½è¦åŒ¹é…æˆåŠŸï¼Œå¦‚æœè¯•å›¾ä»¥ä¸€æ¬¡ä¸æˆåŠŸçš„åŒ¹é…å‡‘å‡ºç¬¬ä¸€ç§æƒ…å†µï¼Œé‚£ä¹ˆè¦åŒ¹é…æˆåŠŸè¿˜è¦äº¤æ¢ä¸€æ¬¡ï¼Œé‚£ä¹ˆä½¿ç”¨ç¬¬äºŒç§ä¹Ÿæ˜¯2æ¬¡ï¼Œåœ¨æ¬¡æ•°ä¸Šæ˜¯æ²¡æœ‰ä»»ä½•ä¸åŒçš„ï¼‰ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é‡‡ç”¨è´ªå¿ƒç®—æ³•ï¼Œéå†æ¯ä¸€ç»„ï¼Œå½“å®ƒçš„æ—è¾¹ä¸æ˜¯å®ƒçš„æƒ…ä¾£æ—¶ï¼Œå°±å‘åéå†å¯»æ‰¾å…¶æƒ…ä¾£ï¼Œè¿›è¡Œäº¤æ¢ç„¶ååŒ¹é…æˆåŠŸï¼Œè¿™é‡Œå› ä¸ºæˆ‘ä»¬å‘ç°ä»–ä»¬çš„idçš„ç‰¹æ®Šæ€§ï¼Œå¯ä»¥åˆ¤æ–­å¥‡å¶ï¼Œå¿«é€Ÿæ‰¾åˆ°å…¶å¦ä¸€åŠã€‚ ä»£ç  12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int minSwapsCouples(vector&lt;int&gt;&amp; row) &#123; int ans = 0; for (int i = 0; i &lt; row.size(); i +=2 ) &#123; int cp; if (row[i] % 2 == 0) &#123; cp = row[i] + 1;//è‹¥ä¸ºå¶æ•°åˆ™æƒ…ä¾£ä¸ºä¸‹ä¸€ä¸ªå¥‡æ•° &#125; else &#123; cp = row[i] - 1;//è‹¥ä¸ºå¥‡æ•°åˆ™æƒ…ä¾£ä¸ºä¸Šä¸€ä¸ªå¶æ•° &#125; if (row[i + 1] == cp) &#123; continue; &#125; ans++; for (int j = i + 2; j&lt; row.size(); j++) &#123; if (row[j] == cp) &#123; int temp = row[i+1]; row[i+1] = row[j]; row[j] = temp; break; &#125; &#125; &#125; return ans; &#125;&#125;; æ€»ç»“ å½“åšåˆ°è¿™é“é¢˜ç›®çš„æ—¶å€™ï¼Œä¾¿æƒ³ä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼Œä½†ä¸€ç›´éƒ½æƒ³ä¸æ¸…æ¥šå¦‚ä½•å»è¯æ˜ï¼Œåæ¥å‘ç°å…¶å®ä»–ä»¬çš„äº¤æ¢å…ˆåæ˜¯æ— å…³çš„ã€‚ æ ¹æ®ç½‘ä¸Šä¸¥è°¨çš„è¯æ˜åº”è¯¥æ˜¯æŠŠrowæŠ½è±¡æˆä¸ºä¸€ä¸ªnä¸ªé¡¶ç‚¹çš„æ— å‘å›¾ï¼Œæ¯ä¸ªé¡¶ç‚¹ä¸­ä¸ºä¸¤ä¸ªäººï¼Œä¸¤ä¸ªé¡¶ç‚¹å­˜åœ¨è¾¹æ—¶å½“ä¸”ä»…å½“ä¸¤ä¸ªé¡¶ç‚¹ä¸­èƒ½æ„æˆä¸€å¯¹æƒ…ä¾£ï¼Œè‹¥æ˜¯ç¬¬ä¸€ç§æƒ…å†µï¼Œåˆ™æ„æˆé‡è¾¹ã€‚ ç›¸è¿çš„é¡¶ç‚¹æ„æˆåœˆï¼Œåœˆé‡Œé¢çš„è‹¥ä¸ºç¬¬äºŒç§æƒ…å†µï¼Œæ‰€ä»¥å¯¹æ¯ä¸€ä¸ªåœˆæ¥è¯´æœ‰nä¸ªé¡¶ç‚¹å°±è‡³å°‘éœ€è¦n-1æ¬¡äº¤æ¢ï¼Œè‹¥ä¸ºç¬¬ä¸€ç§æƒ…å†µï¼Œå³æœ‰é‡è¾¹ï¼Œåªéœ€ä¸€æ¬¡äº¤æ¢ï¼Œä¹Ÿæ˜¯n-1ï¼ˆä¸¤ä¸ªé¡¶ç‚¹ï¼Œ2-1ï¼‰ã€‚ å› æ­¤è‹¥rowæœ‰nç»„ï¼Œmä¸ªåœˆï¼Œåˆ™è‡³å°‘éœ€è¦n-mæ¬¡ã€‚è¿™å’Œä»¥ä¸Šçš„ç»“è®ºæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºä¸åŒåœˆä¹‹é—´å¹¶ä¸ä¼šå‘ç”Ÿäº¤æ¢ã€‚ å…¶å®ƒè§£æ³• ä½¿ç”¨å“ˆå¸Œé…å¯¹çš„æ–¹æ³•ï¼Œä¸¤ä¸ªæ•°å‡é™¤ä»¥2ï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™ä¸ºåŒä¸€ç»„ï¼Œè‹¥å¦ï¼Œåˆ™åŒºåˆ†å‡ºè¾ƒå¤§å’Œè¾ƒå°çš„æ•°ï¼Œè‹¥ä¸¤ä¸ªæ•°å­˜åœ¨è”ç³»ï¼Œåˆ™è¿”å›ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™å»ºç«‹è¿™ä¸¤ä¸ªæ•°çš„è”ç³»ã€‚æœ€åæ ¹æ®å“ˆå¸Œè¡¨ä¸­è”ç³»çš„ä¸ªæ•°æ¥å¾—åˆ°æœ€å°äº¤æ¢æ¬¡æ•°ï¼ŒåŸç†åŒä¸Šé¢çš„ä¸€æ ·ï¼Œè¿™é‡Œçš„è”ç³»å°±æ˜¯æŒ‡çš„æ˜¯é¡¶ç‚¹ä¹‹é—´çš„è¾¹ï¼Œæ¯ä¸ªè¾¹éœ€è¦ä¸€æ¬¡äº¤æ¢ï¼Œé‡è¾¹ç®—ä½œä¸€æ¬¡ï¼Œæ‰€ä»¥æ¯æ¬¡è¦åˆ¤æ–­ä¸¤ä¸ªæ•°æ˜¯å¦å­˜åœ¨è”ç³»ã€‚ ä»£ç ï¼š 12345678910111213141516class Solution &#123;public: int minSwapsCouples(vector&lt;int&gt;&amp; row) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; row.size(); i += 2) &#123; helper(m, row[i] / 2, row[i + 1] / 2); &#125; return m.size(); &#125; void helper(unordered_map&lt;int, int&gt;&amp; m, int x, int y) &#123; int c1 = min(x, y), c2 = max(x, y); if (c1 == c2) return; if (m.count(c1)) helper(m, m[c1], c2); else m[c1] = c2; &#125;&#125;;","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"æ•°å€¼è®¡ç®—å®éªŒä¸€","date":"2018-09-12T11:46:27.000Z","path":"2018/09/12/æ•°å€¼è®¡ç®—å®éªŒä¸€/","text":"æ•°å€¼è®¡ç®—å®éªŒ å®éªŒä¸€ 1.é—®é¢˜æè¿° æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ Ax=bï¼Œå…¶ä¸­ A ä¸º nâ…¹n ç»´çš„å·²çŸ¥çŸ©é˜µï¼Œb ä¸º n ç»´çš„å·²çŸ¥å‘é‡ï¼Œx ä¸º n ç»´çš„æœªçŸ¥å‘é‡ã€‚ A ä¸ b ä¸­çš„å…ƒç´ æœä»ç‹¬ç«‹åŒåˆ†å¸ƒçš„æ­£æ€åˆ†å¸ƒã€‚ä»¤ n=10ã€50ã€100ã€200ï¼Œæµ‹è¯•è®¡ç®—æ—¶é—´å¹¶ç»˜åˆ¶æ›²çº¿ã€‚ ï¼ˆ1ï¼‰é«˜æ–¯æ¶ˆå»æ³•ã€‚ ï¼ˆ2ï¼‰åˆ—ä¸»å…ƒæ¶ˆå»æ³•ã€‚ 2.ç®—æ³•è®¾è®¡ é«˜æ–¯æ¶ˆå»æ³• ï¼ˆ1ï¼‰æ¶ˆå…ƒï¼šä½¿ç”¨é€æ¬¡æ¶ˆå»æœªçŸ¥æ•°çš„æ–¹æ³•æŠŠåŸçº¿æ€§æ–¹ç¨‹ç»„Ax = båŒ–ä¸ºä¸å…¶ç­‰ä»·çš„ä¸‰è§’å½¢çº¿æ€§æ–¹ç¨‹ç»„ã€‚ åœ¨è¿™é‡Œä½¿ç”¨å°†æ–¹ç¨‹ä¹˜ä»¥æŸä¸€ä¹˜æ•°åŠ åˆ°å…¶å®ƒæ–¹ç¨‹ä¸Šä»¥è¿›è¡Œæ¶ˆå…ƒï¼Œä¹˜æ•°ä¸ºä¸¤ä¸ªæœªçŸ¥æ•°ä¹‹å•†ã€‚å¾—åˆ°ç­‰ä»·çš„ä¸‰è§’å½¢çº¿æ€§æ–¹ç¨‹ç»„ã€‚ ï¼ˆ2ï¼‰å›ä»£ï¼šæ±‚è§£ä¸Šä¸‰è§’çº¿æ€§æ–¹ç¨‹ç»„åˆ©ç”¨å›ä»£çš„æ–¹æ³•ï¼Œä»ä¸‹è‡³ä¸Šæ±‚å‡ºæ–¹ç¨‹ç»„ä¸­çš„ä¸€æ–¹ç¨‹çš„æœªçŸ¥æ•°ï¼Œç„¶åé€å±‚å›ä»£æ±‚å‡ºå…¶å®ƒæ–¹ç¨‹çš„æœªçŸ¥æ•°ã€‚ åˆ—ä¸»å…ƒæ¶ˆå»æ³• ä¸é«˜æ–¯æ¶ˆå»æ³•ç±»ä¼¼ï¼Œåœ¨æ¶ˆå…ƒé˜¶æ®µè¿›è¡Œäº¤æ¢è¡Œï¼Œé€‰å–ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ä½œä¸ºä¸»å…ƒç´ ï¼Œé¿å…ä¸»å…ƒç´ ä¸º0ï¼Œæ— æ³•è¿›è¡Œæ¶ˆå…ƒï¼Œä»¥åŠå½“ä¸»å…ƒç´ å¾ˆå°æ—¶ï¼Œä½œé™¤æ•°å¯¼è‡´æ•°å€¼ä¸ç¨³å®šäº§ç”Ÿè¾ƒå¤§çš„è¯¯å·®ã€‚ å›ä»£æ–¹æ³•å’Œé«˜æ–¯æ¶ˆå»æ³•ä¸€è‡´ã€‚ 3.æ•°å€¼å®éªŒ éšæœºæ„é€ å‡ºå¤šä¸ªçŸ©é˜µä»¥åŠå¤šä¸ªå‘é‡ï¼ŒçŸ©é˜µå’Œå‘é‡çš„ç»´æ•°nåˆ†åˆ«ä¸º10ã€50ã€100ã€200ï¼ŒåŒæ—¶ä½¿ç”¨é«˜æ–¯æ¶ˆå»æ³•ï¼Œåˆ—ä¸»å…ƒæ¶ˆå»æ³•è¿›è¡Œçº¿æ€§æ–¹ç¨‹ç»„çš„æ±‚è§£ï¼Œæ¯”è¾ƒä¸¤ç§ç®—æ³•çš„è®¡ç®—æ—¶é—´ä»¥åŠå…¶è®¡ç®—æ—¶é—´ä¸çŸ©é˜µçš„ç»´æ•°ï¼ˆå¤§å°ï¼‰çš„å…³ç³»ã€‚ å®éªŒç»“æœä¸€ï¼š test1 å®éªŒç»“æœäºŒï¼š test1-1 â€‹ è¿›è¡Œæ‹Ÿåˆï¼š æ‹Ÿåˆ 4.ç»“æœåˆ†æ é€šè¿‡è¿›è¡Œè®¡ç®—æ—¶é—´çš„æµ‹è¯•ï¼Œå¹¶ç»˜åˆ¶æ›²çº¿å¾—åˆ°å®éªŒç»“æœï¼Œè§‚å¯Ÿå¯å¾—åˆ—ä¸»å…ƒæ¶ˆå»æ³•å› ä¸ºè¦è¿›è¡ŒæŸ¥æ‰¾ç»å¯¹å€¼æœ€å¤§ä¸»å…ƒç´ ï¼Œå¹¶è¿›è¡Œäº¤æ¢ä½¿å¾—è®¡ç®—æ—¶é—´æ¯”æ™®é€šé«˜æ–¯æ¶ˆå»æ–¹æ³•ç¨é•¿ï¼Œä½†ä¸¤è€…çš„è®¡ç®—æ—¶é—´è¿˜æ˜¯ç›¸è¿‘ã€‚ å¦å¤–å½“çŸ©é˜µçš„ç»´æ•°ï¼ˆå¤§å°ï¼‰å˜å¤§ï¼Œè¿™ç§æ¶ˆå…ƒå›ä»£æ–¹æ³•çš„è®¡ç®—æ—¶é—´ä¹Ÿå¤§å¹…åº¦å¢é•¿ï¼Œé€šè¿‡å‡½æ•°çš„æ‹Ÿåˆå‘ç°å…¶è®¡ç®—æ—¶é—´ä¸ºOï¼ˆn^3ï¼‰çš„ï¼Œnä¸ºçŸ©é˜µçš„ç»´æ•°ã€‚ å®éªŒäºŒ 1.é—®é¢˜æè¿° æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ Ax=bï¼Œå…¶ä¸­ A ä¸º nâ…¹n ç»´çš„å·²çŸ¥çŸ©é˜µï¼Œb ä¸º n ç»´çš„å·²çŸ¥å‘é‡ï¼Œx ä¸º n ç»´çš„æœªçŸ¥å‘é‡ã€‚ A ä¸ºå¯¹ç§°æ­£å®šçŸ©é˜µï¼Œå…¶ç‰¹å¾å€¼æœä»ç‹¬ç«‹åŒåˆ†å¸ƒçš„[0,1]é—´çš„å‡åŒ€åˆ†å¸ƒï¼›b ä¸­çš„å…ƒç´ æœä»ç‹¬ç«‹åŒåˆ†å¸ƒçš„æ­£æ€åˆ†å¸ƒã€‚ ä»¤ n=10ã€50ã€100ã€200ï¼Œåˆ†åˆ«ç»˜åˆ¶å‡ºç®—æ³•çš„æ”¶æ•›æ›²çº¿ï¼Œæ¨ªåæ ‡ä¸ºè¿­ä»£æ­¥æ•°ï¼Œçºµåæ ‡ä¸ºç›¸å¯¹è¯¯å·®ã€‚æ¯”è¾ƒJacobi è¿­ä»£æ³•ã€Gauss-Seidel è¿­ä»£æ³•ã€é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ³•ã€å…±è½­æ¢¯åº¦æ³•ä¸é«˜æ–¯æ¶ˆå»æ³•ã€åˆ—ä¸»å…ƒæ¶ˆå»æ³•çš„è®¡ç®—æ—¶é—´ã€‚æ”¹å˜é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ³•çš„æ¾å¼›å› å­ï¼Œåˆ†æå…¶å¯¹æ”¶æ•›é€Ÿåº¦çš„å½±å“ã€‚ 2.ç®—æ³•è®¾è®¡ Jacobiè¿­ä»£æ³• é›…å¯æ¯”è¿­ä»£æ³•çš„æ€æƒ³åœ¨äºæŠŠå½“å‰çš„xåˆå§‹é‡å½“æˆæ–¹ç¨‹ç»„çš„è§£ï¼Œä»è€Œè¿›è¡Œå›ä»£å¾—å‡ºä¸‹ä¸€æ­¥xçš„è¿‘ä¼¼è§£ï¼Œè¿™ç§æ–¹æ³•æ¯æ¬¡è¿­ä»£éƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡è¿­ä»£çš„xï¼Œè‹¥è¿­ä»£çŸ©é˜µè°±åŠå¾„&lt;1ï¼Œåˆ™åœ¨ä¸€å®šè¿­ä»£æ¬¡æ•°åï¼Œxä¼šæ”¶æ•›æˆç²¾ç¡®è§£ã€‚ Gauss-Seidel è¿­ä»£æ³• é«˜æ–¯-èµ›å¾·å°”è¿­ä»£ä¸é›…å¯æ¯”è¿­ä»£ç±»ä¼¼ï¼Œä½†æ˜¯åœ¨æ¯æ¬¡è¿­ä»£ä¹‹ä¸­ä½¿ç”¨å˜é‡çš„æœ€æ–°ä¿¡æ¯è®¡ç®—x(k+1)ï¼Œæ˜¯é›…å¯æ¯”è¿­ä»£æ³•çš„æ”¹è¿›ã€‚ é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ³• é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ˜¯é«˜æ–¯-èµ›å¾·å°”è¿­ä»£çš„ä¸€ç§ä¿®æ­£ï¼Œå½“w ä¸º1 æ—¶å³ä¸ºé«˜æ–¯-èµ›å¾·å°”è¿­ä»£ï¼Œå³åœ¨æ¯ä¸€æ­¥çš„è¿­ä»£åï¼Œå¯¹ä¸Šä¸€æ­¥çš„\\(x^(k)\\)å’Œè¿­ä»£åçš„xâ€˜è¿›è¡ŒåŠ æƒè¿ç®— x(k+1)=(1âˆ’w)âˆ—x(k)+wâˆ—x(k)x(k+1) = (1-w)*x(k)+ w*x(k)x(k+1)=(1âˆ’w)âˆ—x(k)+wâˆ—x(k)ï¼Œè¶…æ¾å¼›è¿­ä»£w&gt;1ï¼Œä¸€èˆ¬ä¸º1&lt;w&lt;2ï¼Œç›¸å½“äºåšå¤–æ’ï¼ŒåŠ å¿«æ”¶æ•›é€Ÿåº¦ã€‚ å…±è½­æ¢¯åº¦æ³• å°†è§£çº¿æ€§æ–¹ç¨‹ç»„è½¬åŒ–æˆæ±‚è§£ä¸€ä¸ªç­‰ä»·çš„äºŒæ¬¡å‡½æ•°\\(f(x) = 1/2* x^T * A *x - b^T *x\\)æå°åŒ–çš„é—®é¢˜ï¼Œä»ä»»æ„èµ·å§‹ç‚¹å‡ºå‘æ²¿Açš„å…±è½­æ–¹å‘è¿›è¡Œçº¿æ€§æœç´¢å¾—åˆ°äºŒæ¬¡å‡½æ•°çš„æå°ç‚¹ã€‚ 3.æ•°å€¼å®éªŒ å››ç§è¿­ä»£æ³•çš„æ”¶æ•› n = 10çš„æ”¶æ•›æ›²çº¿ï¼šï¼ˆSORæ”¶æ•›å› å­w ä¸º1.1ï¼‰ test2-1 n = 50çš„æ”¶æ•›æ›²çº¿ï¼š test2-2 n = 100çš„æ”¶æ•›æ›²çº¿ï¼š test2-3 n = 200çš„æ”¶æ•›æ›²çº¿ï¼š test2-4 å…­ç§ç®—æ³•è®¡ç®—æ—¶é—´çš„æ¯”è¾ƒ n = 10ï¼š test2-5 n = 50ï¼š test2-6 n = 100ï¼š test2-7 n = 200ï¼š test2-8 é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ¾å¼›å› å­ï¼ˆwï¼‰çš„å½±å“ å®Œæ•´çš„å›¾ï¼šï¼ˆæ­¤æ—¶n =200ï¼‰ test3 Yï¼šï¼ˆ0ï¼Œ0.5ï¼‰ 4.ç»“æœåˆ†æ æ ¹æ®å®éªŒäºŒçš„ç»“æœå¯å¾—åœ¨å››ç§è¿­ä»£æ³•ä¸­ï¼Œé›…å¯æ¯”è¿­ä»£æ³•æ”¶æ•›æ€§è¾ƒå·®ï¼Œæ®å…¶æ”¹è¿›çš„é«˜æ–¯-èµ›å¾·å°”åˆ™è¾ƒå¥½ï¼Œè€Œå¢åŠ äº†åŠ æƒå¹³å‡è¿›è¡Œå¤–æ’è¿ç®—çš„é€æ¬¡è¶…æ¾å¼›è¿­ä»£æ”¶æ•›é€Ÿåº¦æ›´å¿«ï¼Œæ”¶æ•›é€Ÿåº¦æœ€å¿«çš„åˆ™æ˜¯å…±è½­æ¢¯åº¦æ³•ã€‚ è€Œå…­ç§ç®—æ³•çš„è®¡ç®—æ—¶é—´ä¸­å¯ä»¥çœ‹å‡ºï¼Œå½“çŸ©é˜µè¾ƒå°æ—¶ï¼Œè¿­ä»£æ³•å’Œæ¶ˆå…ƒæ³•è®¡ç®—æ—¶é—´ç›¸å·®ä¸å¤§ï¼ŒçŸ©é˜µè¾ƒå¤§æ—¶ï¼Œå…±è½­æ¢¯åº¦æ³•åœ¨è®¡ç®—æ—¶é—´ä¸­æœ‰ç€è¾ƒå¤§çš„ä¼˜åŠ¿ï¼Œè¾¾åˆ°æ‰€éœ€ç²¾åº¦çš„è¿­ä»£æ¬¡æ•°æ¯”å…¶å®ƒè¿­ä»£æ¬¡æ•°è¦å°‘å¾ˆå¤šï¼Œå¹¶ä¸”æ¯æ¬¡è¿­ä»£è€—æ—¶è¾ƒå°‘ã€‚å› ä¸ºæ„é€ çš„çŸ©é˜µå¹¶ä¸æ˜¯ç¨€ç–çŸ©é˜µï¼Œæ‰€ä»¥åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ™®é€šçš„æ¶ˆå…ƒæ³•æ¯”å…¶å®ƒè¿­ä»£æ³•æ‰€è€—æ—¶é—´è¦å°‘ã€‚ åœ¨åˆ†ææ¾å¼›å› å­å¯¹æ”¶æ•›é€Ÿåº¦å½±å“ä¸­ï¼Œæ¾å¼›å› å­å¯¹ç®—æ³•çš„æ”¶æ•›é€Ÿåº¦å½±å“å¾ˆå¤§ï¼Œé€‰æ‹©åˆé€‚çš„æ¾å¼›å› å­èƒ½å¤Ÿå‡å°‘ç®—æ³•çš„è¿­ä»£æ¬¡æ•°ï¼Œåœ¨è¾ƒå°‘çš„è¿­ä»£æ¬¡æ•°å¾—åˆ°è¾ƒä¸ºç²¾ç¡®çš„ç»“æœï¼Œå¯¹äºä¸åŒçš„çŸ©é˜µæœ‰ç€ä¸åŒçš„æœ€ä½³æ¾å¼›å› å­ï¼Œå¯¹äºæœ¬æ¬¡æ¨¡æ‹Ÿçš„çŸ©é˜µwè¾ƒå¤§åˆ™æœ€å¥½ï¼Œä½†æ˜¯wè¶…è¿‡2ä¹‹åï¼Œç®—æ³•åˆ™ä¸å†æ”¶æ•›ã€‚ å®éªŒä¸‰ 1.é—®é¢˜æè¿° åœ¨ Epinions ç¤¾äº¤æ•°æ®é›†ä¸­ï¼Œæ¯ä¸ªç½‘ç»œèŠ‚ç‚¹å¯ä»¥é€‰æ‹©ä¿¡ä»»å…¶å®ƒèŠ‚ç‚¹ã€‚å€Ÿé‰´ Pagerank çš„æ€æƒ³ç¼–å†™ç¨‹åºï¼Œå¯¹ç½‘ç»œèŠ‚ç‚¹çš„å—ä¿¡ä»»ç¨‹åº¦è¿›è¡Œè¯„åˆ†ã€‚åœ¨å®éªŒæŠ¥å‘Šä¸­ï¼Œè¯·ç»™å‡ºä¼ªä»£ç ã€‚ 2.ç®—æ³•è®¾è®¡ å’Œpagerankç›¸ç±»ä¼¼ï¼Œé¢„å…ˆç»™æ¯ä¸ªç½‘ç»œèŠ‚ç‚¹ä¸€ä¸ªä¿¡ä»»å€¼Trustå€¼ä¸º1/Nï¼ŒNä¸ºèŠ‚ç‚¹çš„æ•°é‡ï¼Œè¿™æ ·å°±èƒ½å¾—åˆ°ä¸€ä¸ªå‘é‡vä»£è¡¨æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡ä»»è¯„åˆ†rank v=[1/n,1/n,1/n,â€¦â€¦]v = [1/n,1/n,1/n,â€¦â€¦] v=[1/n,1/n,1/n,â€¦â€¦] å‡å®šæ¯ä¸ªèŠ‚ç‚¹çš„å¯¹å…¶ä»–èŠ‚ç‚¹çš„æ€»çš„ä¿¡ä»»ç¨‹åº¦ä¸º1ï¼Œè€Œä¸”å¯¹æ¯ä¸ªå…¶ä¿¡ä»»çš„èŠ‚ç‚¹éƒ½ç»™äºˆç›¸åŒçš„ä¿¡ä»»ç¨‹åº¦ï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªä¿¡ä»»è½¬ç§»çŸ©é˜µAã€‚ Aï¼ˆiï¼Œjï¼‰= èŠ‚ç‚¹iå¯¹èŠ‚ç‚¹jçš„ä¿¡ä»»ç¨‹åº¦ æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡ä»»è¯„åˆ†rankç”±ä¿¡ä»»å®ƒçš„èŠ‚ç‚¹å†³å®šï¼Œå¦‚æœä¿¡ä»»è¯„åˆ†çš„èŠ‚ç‚¹æœ¬èº«çš„ä¿¡ä»»è¯„åˆ†é«˜ï¼Œåˆ™ç»™äºˆçš„è¯„åˆ†æƒé‡ä¹Ÿé«˜ï¼Œåä¹‹ç»™äºˆè¯„åˆ†æƒé‡è¾ƒä½ã€‚ æ‰€ä»¥é€šè¿‡è®¡ç®— vâ€˜ = Mv å³ v(i) = âˆ‘å…¶å®ƒèŠ‚ç‚¹ä¿¡ä»»è¯„åˆ†v(j)*ä¿¡ä»»ç¨‹åº¦A(i,j) å¯ä»¥å¾—åˆ°æ–°çš„ä¸€ä¸ªä¿¡ä»»è¯„åˆ†ï¼Œç»è¿‡æœ‰é™æ¬¡çš„è¿­ä»£ï¼Œvâ€™å°†ä¼šæ”¶æ•›ç¨³å®šä¸‹æ¥ï¼Œå¾—åˆ°çš„å³æ˜¯å„ä¸ªèŠ‚ç‚¹çš„ä¿¡ä»»è¯„åˆ†ã€‚ æ”¹è¿› å¯¹äºä¸€äº›åªä¿¡ä»»è‡ªå·±çš„ï¼Œå¯¹å…¶å®ƒèŠ‚ç‚¹å¹¶æœªä½œå‡ºä¿¡ä»»çš„ç½‘é¡µèŠ‚ç‚¹ï¼Œé‡‡ç”¨è¿™ç§ç®—æ³•æœ‰2ä¸ªç¼ºç‚¹ 1.ä½¿å¾—ä¿¡ä»»è¯„åˆ†éƒ½é›†ä¸­åˆ°é‚£ä¸€å¾ªç¯çš„èŠ‚ç‚¹ä¸Šã€‚ 2.å¯¹äºæ–°å»ºç«‹çš„ç½‘ç»œèŠ‚ç‚¹æ¥è¯´ï¼Œå¹¶ä¸å…¬å¹³ï¼Œå› ä¸ºä¸€å¼€å§‹æ²¡æœ‰å…¶ä»–èŠ‚ç‚¹ä¿¡ä»»å®ƒï¼Œå¯èƒ½å¯¼è‡´ä¿¡ä»»è¯„åˆ†æ¶æ€§å¾ªç¯ã€‚ å› æ­¤æ·»åŠ ä¸€ä¸ªæƒé‡å æ¯”Î±ï¼ŒåŸå…ˆçš„è¯„åˆ†ä»…å Î±ï¼Œç„¶åé»˜è®¤æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½å¯¹å…¶å®ƒèŠ‚ç‚¹æœ‰ä¸€å®šç¨‹åº¦ï¼ˆè¾ƒå°ä½†ä¸ä¸º0ï¼‰çš„ä¿¡ä»»ï¼Œè¿™ä¸ªä¿¡ä»»ç¨‹åº¦å½±å“è¯„åˆ†æ‰€å çš„æƒé‡ä¸º1-Î±ã€‚å› æ­¤è¿­ä»£å…¬å¼å˜ä¸ºï¼š v(i)=âˆ‘v(j)âˆ—A(i,j)âˆ—Î±+(1âˆ’Î±)/Nv(i) = âˆ‘v(j)*A(i,j)*Î±+(1-Î±)/N v(i)=âˆ‘v(j)âˆ—A(i,j)âˆ—Î±+(1âˆ’Î±)/N Î±ä¸€èˆ¬è®¾å®šä¸º0.85ã€‚ 3.ä¼ªä»£ç  A = [N,N]; Î± = 0.85;%è®¾å®šæƒé‡ %æ„å»ºè½¬ç§»çŸ©é˜µï¼Œå³ä¿¡ä»»å…³ç³»çŸ©é˜µ for i = 1: N for j = 1 : N A[i,j] = 1/n(n ä¸ºiçš„æ‰€æœ‰å‡ºé“¾ï¼Œå³ç»™äºˆä¿¡ä»»çš„èŠ‚ç‚¹æ•°æ€»æ•°) end end %åˆå§‹åŒ–ä¿¡ä»»è¯„åˆ†rank v0(1:N) = 1/N; v = v0 %è¿­ä»£ while norm(v-v0,'inf')>0.01 %å½“vé€æ¸æ”¶æ•›åç»“æŸè¿­ä»£ v0 = v; for i = 1: N sum = 0; for j = 1 : N %è®¡ç®—å…¶å®ƒèŠ‚ç‚¹ç»™äºˆè¯¥èŠ‚ç‚¹çš„ä¿¡ä»»è¯„åˆ† sum = sum + A(j,i)*v0(j)*Î± + (1-Î±)/N end v(i) = sum; end end disp(v');","tags":[]},{"title":"[LeetCode] 75. Sort Colors","date":"2018-09-09T02:46:00.000Z","path":"2018/09/09/Leetcode-75-Sort-Colors/","text":"Sort Colors week1 é¢˜ç›®é“¾æ¥ é¢˜ç›®æè¿° Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the libraryâ€™s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? è§£é¢˜æ€è·¯ è¿™é“é¢˜ä¸»è¦æ˜¯å¯¹å·²çŸ¥æ•°çš„æ’åºï¼Œæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªæ•°çš„èŒƒå›´éƒ½å·²ç¡®å®šï¼Œå› æ­¤ç”¨ä»¥å¾€çš„æ’åºå¦‚å¿«æ’ï¼Œå½’å¹¶æ’åºå¹¶ä¸åˆé€‚ï¼Œè¦åšåˆ°ä¸€æ¬¡éå†å®Œæˆå¹¶ä½¿ç”¨å¸¸ç©ºé—´ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©ä½¿ç”¨æ’æ’æ¥å®Œæˆã€‚ å…ˆä½¿ç”¨æ™®é€šçš„æ’æ’å‘ç°æ—¶é—´ä¼šå¾ˆæ…¢ï¼Œè€Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å‘ç°ä¸€èˆ¬çš„æ’æ’éƒ½æ˜¯é€ä¸ªæ¯”è¾ƒçš„ï¼Œè€Œè¿™é“é¢˜ç›®çš„ç‰¹æ®Šç‚¹åœ¨äºæ•°çš„ç§ç±»è¾ƒå°‘åªæœ‰3ä¸ªï¼Œè€Œä¸”æ˜¯å·²çŸ¥çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è®°å½•ä¸‹æ¯ä¸ªæ•°åº”æ’åˆ°çš„ä½ç½®ï¼Œå°±èŠ‚çœäº†æ¯”è¾ƒçš„è¿‡ç¨‹ã€‚ è®°å½•ä¸‹0ï¼Œ1ï¼Œ2çš„å¯æ’å…¥ç‚¹çš„å‰ä¸€ä½ï¼Œæ¯”å¦‚æ’å…¥1åï¼Œ1å¯æ’ç‚¹å‘åç§»ï¼Œè€Œ2å› ä¸ºåªèƒ½åœ¨1åï¼Œæ‰€ä»¥ä¹Ÿå‘åç§»ï¼Œè€Œ0ä¸å—1å½±å“ï¼Œæ’å…¥ç‚¹ä¸å˜ã€‚æœ€é‡è¦çš„ä¸€ç‚¹æ˜¯å½“æ’å…¥0/1æ—¶ï¼Œä¼šæ›¿æ¢æ‰åŸæœ¬çš„æ•°ï¼Œå› ä¸ºåé¢çš„æ•°å‘åç§»åŠ¨ï¼Œå¯ä»¥å½“ä½œ(1ï¼Œ2)/2ä¹Ÿæ’å…¥åˆ°æ•°ç»„ä¸­ï¼ˆåç§»æ›¿æ¢æ‰åŸæœ¬çš„æ•°ï¼‰ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int red = -1, white = -1, blue = -1; for(int i = 0; i &lt; nums.size(); i ++) &#123; if(nums[i] == 0) &#123; red++; white++; blue++; nums[blue] = 2; nums[white] = 1; nums[red] = 0; &#125; else if(nums[i] == 1) &#123; white++; blue++; nums[blue] = 2; nums[white] = 1; &#125; else &#123; blue++; nums[blue] = 2; &#125; &#125; &#125;&#125;; Note å€¼å¾—æ³¨æ„çš„æ˜¯æˆ‘ä»¬åœ¨å†™çš„æ—¶å€™ï¼Œè¦æŠŠè¦æ’å…¥çš„æ­¥éª¤å†™åœ¨å…¶å®ƒæ•°åšå®Œåç§»æ“ä½œä¹‹åï¼Œå› ä¸ºå­˜åœ¨ä¸€ç§å¯èƒ½å‡è®¾ç°åœ¨æ•´ä¸ªæ•°ç»„ä¸­è¿˜ä¸å­˜åœ¨1ï¼Œå½“ä½ è¦æ’å…¥0æ—¶ï¼Œæ­¤æ—¶0å’Œ1çš„æ’å…¥ç‚¹æ˜¯ç›¸åŒçš„ï¼Œå‡è®¾ä½ å…ˆæ’å…¥å†åç§»ï¼Œä¼šä½¿å¾—æ’å…¥çš„0è¢«1æ›¿æ¢æ‰ï¼ˆå› ä¸ºæˆ‘ä»¬çš„åç§»æ“ä½œæ˜¯å‡è®¾1çš„æ’å…¥ç‚¹å‰æ˜¯1ï¼Œ0çš„æ’å…¥ç‚¹å‰æ˜¯0ï¼‰ï¼Œåä¹‹1è¢«0æ›¿æ¢åˆ™æ­£ç¡®ã€‚ è¿™ç§ç®—æ³•é€‚åˆäºå·²çŸ¥æ•°ä¸”ä¸åŒæ•°è¾ƒå°‘çš„æ’åºï¼Œç”¨æ›¿æ¢å–ä»£åç§»ï¼ŒèŠ‚çœæ—¶é—´å’Œç©ºé—´ã€‚ æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦å‡ä¸ºå¸¸æ•°ã€‚","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ziquanzhang.ink/tags/LeetCode/"}]},{"title":"I am a title","date":"2018-09-05T07:59:00.000Z","path":"2018/09/05/I-am-a-title-1/","text":"Welcome to StackEdit! Hi! Iâ€™m your first Markdown file in StackEdit. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the file explorer on the left corner of the navigation bar. Files StackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible offline! Create files and folders The file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the New file button in the file explorer. You can also create folders by clicking the New folder button. Switch to another file All your files are listed in the file explorer. You can switch from one to another by clicking a file in the list. Rename a file You can rename the current file by clicking the file name in the navigation bar or by clicking the Rename button in the file explorer. Delete a file You can delete the current file by clicking the Remove button in the file explorer. The file will be moved into the Trash folder and automatically deleted after 7 days of inactivity. Export a file You can export the current file by clicking Export to disk in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF. Synchronization Synchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your Google Drive, your Dropbox and your GitHub accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflowâ€¦ The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications. There are two types of synchronization and they can complement each other: The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device. To start syncing your workspace, just sign in with Google in the menu. The file synchronization will keep one file of the workspace synced with one or multiple files in Google Drive, Dropbox or GitHub. Before starting to sync files, you must link an account in the Synchronize sub-menu. Open a file You can open a file from Google Drive, Dropbox or GitHub by opening the Synchronize sub-menu and clicking Open from. Once opened in the workspace, any modification in the file will be automatically synced. Save a file You can save any file of the workspace to Google Drive, Dropbox or GitHub by opening the Synchronize sub-menu and clicking Save on. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts. Synchronize a file Once your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved. If you just have modified your file and you want to force syncing, click the Synchronize now button in the navigation bar. Note: The Synchronize now button is disabled if you have no file to synchronize. Manage file synchronization Since one file can be synced with multiple locations, you can list and manage synchronized locations by clicking File synchronization in the Synchronize sub-menu. This allows you to list and remove synchronized locations that are linked to your file. Publication Publishing in StackEdit makes it simple for you to publish online your files. Once youâ€™re happy with a file, you can publish it to different hosting platforms like Blogger, Dropbox, Gist, GitHub, Google Drive, WordPress and Zendesk. With Handlebars templates, you have full control over what you export. Before starting to publish, you must link an account in the Publish sub-menu. Publish a File You can publish your file by opening the Publish sub-menu and by clicking Publish to. For some locations, you can choose between the following formats: Markdown: publish the Markdown text on a website that can interpret it (GitHub for instance), HTML: publish the file converted to HTML via a Handlebars template (on a blog for example). Update a publication After publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the Publish now button in the navigation bar. Note: The Publish now button is disabled if your file has not been published yet. Manage file publication Since one file can be published to multiple locations, you can list and manage publish locations by clicking File publication in the Publish sub-menu. This allows you to list and remove publication locations that are linked to your file. Markdown extensions StackEdit extends the standard Markdown syntax by adding extra Markdown extensions, providing you with some nice features. ProTip: You can disable any Markdown extension in the File properties dialog. SmartyPants SmartyPants converts ASCII punctuation characters into â€œsmartâ€ typographic punctuation HTML entities. For example: ASCII HTML Single backticks 'Isn't this fun?' â€˜Isnâ€™t this fun?â€™ Quotes &quot;Isn't this fun?&quot; â€œIsnâ€™t this fun?â€ Dashes -- is en-dash, --- is em-dash â€“ is en-dash, â€” is em-dash KaTeX You can render LaTeX mathematical expressions using KaTeX: The Gamma function satisfying Î“(n)=(nâˆ’1)!âˆ€nâˆˆN\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb NÎ“(n)=(nâˆ’1)!âˆ€nâˆˆN is via the Euler integral Î“(z)=âˆ«0âˆtzâˆ’1eâˆ’tdt.\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. Î“(z)=âˆ«0âˆâ€‹tzâˆ’1eâˆ’tdt. You can find more information about LaTeX mathematical expressions here. UML diagrams You can render UML diagrams using Mermaid. For example, this will produce a sequence diagram: 123456789sequenceDiagramAlice -&gt;&gt; Bob: Hello Bob, how are you?Bob--&gt;&gt;John: How about you John?Bob--x Alice: I am good thanks!Bob-x John: I am good thanks!Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.Bob--&gt;Alice: Checking with John...Alice-&gt;John: Yes... John, how are you? And this will produce a flow chart: 12345graph LRA[Square Rect] -- Link text --&gt; B((Circle))A --&gt; C(Round Rect)B --&gt; D&#123;Rhombus&#125;C --&gt; D","tags":[{"name":"test","slug":"test","permalink":"http://ziquanzhang.ink/tags/test/"}]},{"title":"Hello World","date":"2018-09-04T10:58:54.147Z","path":"2018/09/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","tags":[]}]