[{"title":"[Cocos2dx] ","date":"2018-09-12T08:33:00.000Z","path":"2018/09/12/Cocos2dx/","text":"现代操作系统应用开发实验报告​ 姓名： 张子权_ ​ 学号：16340296 ​ 实验名称： homework5 一、参考资料http://www.cocos.com/docs/native/v3/particle-system/zh.html http://www.cocos2d-x.org/docs/programmers-guide/physics/index.html http://blog.csdn.net/fansongy/article/details/14142323 http://www.cocos2d-x.org/docs/api-ref/cplusplus/v3x/d2/d8a/classcocos2d_1_1_physics_joint.html https://blog.csdn.net/zy19940906/article/details/52025460 二、实验要求Lucia2.0第十三周为在上一周的基础上添加怪物，场景。（主要学习怪物工厂机制，数据结构以及本地存储） 要求：1.产生怪物并向玩家靠近，怪物攻击角色掉血，角色血量归零则死亡。 2.角色可攻击怪物，攻击中后回血，且记录怪物数量（建立数据库）。 3.使用Tilemap建立游戏地图。 Thunder第十四周为射击游戏。（主要学习事件处理和添加音效、音乐） upload successful 要求：1.使用键盘移动player，触摸为子弹发射。（附加鼠标移动） 2.player发射子弹击毁陨石/陨石碰撞飞船爆炸。（产生音效） 3.显示当前页面的子弹和陨石数，添加背景音乐。 HitBrick第十五周设计打砖头游戏。（学习cocos2dx物理引擎与粒子系统） 要求：1.通过键盘移动板子左右，并在开始时用关节固定球和板子。 2.顶部生成小砖块，给板子、球、以及砖块设置物理属性。（给球等等添加粒子效果） 3.添加碰撞事件监听器，砖球碰撞消去砖头，球地碰撞游戏结束。 三、实验步骤Lucia2.01.创建怪物工厂这个类，来统一生成怪物，移动怪物，判断怪物的碰撞以及移除怪物。使用一个向量表来存储已生成的怪物。实例化工厂到地图中，使用调度器来定时调用Factory::createMonster(),定时生成怪物。在此同时也调用Factory::moveMonster()使得怪物向角色移动： for (auto i : monster) { Vec2 Pos = i->getPosition(); Vec2 dir = playerPos - Pos; dir.normalize(); i->runAction(MoveBy::create(time, dir * 30)); } 当怪物碰撞到角色时，调用函数减少玩家生命值，并将怪物移除： Sprite* collision = fac->collider(player->getBoundingBox()); if (collision != NULL) { auto hppercent = pT->getPercentage(); changeHp(false); fac->removeMonster(collision); } 当玩家生命值归零调用gameover()函数. //判断是否死亡 if (pT->getPercentage() == 0 && !isDead) { player->stopAllActions(); isDead = true; //播放死亡动画 auto animate = Animate::create(AnimationCache::getInstance()->getAnimation(\"dead\")); player->runAction(animate); //保存数据，一个是本地临时存储，一个是数据库。 UserDefault::sharedUserDefault()->setIntegerForKey(\"Score\", dscore); saveData(); } 2.玩家移动时，设置向左和向右的时候有一个标志，当向左时，设置player-&gt;setFlipX(true);，将图片X镜像，调反过来。向右时恢复原图。玩家攻击怪物回血与怪物碰撞玩家相似，只不过是以玩家为基点，扩大碰撞范围，在此范围内怪物将被攻击到并移除。同时玩家回血。（因可能同时攻击多个怪物，所以使用while循环）。 while (true) { Sprite* collision = fac->collider(attackRect); if (collision == NULL) break; changeHp(true); fac->removeMonster(collision); dscore++; } 3.创建tilemap则TMXTiledMap* tmx = TMXTiledMap::create(&quot;mymap.tmx&quot;);即可插入地图，调整其位置覆盖满整个游戏。至于数据库存储，使用cocos2dx自带的sqlite3，打开使用sqlite3_open(&quot;score.db&quot;, &amp;pDB);，创建Score表sqlite3_exec(pDB, &quot;create table myTable( ID integer primary key autoincrement, score integer ) &quot;，用数据库操作保存数据。 Thunder1.利用键盘移动Player主要添加键盘事件监听器，当发生按键时，记录所按键位，并在调度器中根据键位来调用移动函数Thunder::movePlane(char c)，触摸同理，当发生触摸事件，即返回isClick = true，调用Thunder::fire()，来进行发射子弹。通过鼠标控制移动则在onTouchMoved中设置当鼠标移动时，飞船跟随，并且isClick = false，不发射： isClick = false; if (isvalidLoc(touch->getLocation())) { player->setPosition(Vec2(touch->getLocation().x, player->getPosition().y)); } 2.自定义子弹打中陨石碰撞事件，通过调度器分发事件，先遍历所有陨石，每个陨石遍历所有子弹，即可避免子弹击中的先后问题，当子弹距离陨石一定范围，移除子弹、陨石，播放爆炸动画/音效：（陨石击中飞船同理，此时额外调用游戏结束的函数）这里的播放使用了sequence + callfunc的方法，在播放完动画后移除陨石。 Sprite* temp = (*it1); (*it1)->runAction( Sequence::create( Animate::create( Animation::createWithSpriteFrames(explore, 0.05f, 1) ), CallFunc::create([temp] { temp->removeFromParentAndCleanup(true); }), nullptr ) ); //播放音效 SimpleAudioEngine::getInstance()->playEffect(\"/music/explore.wav\", false); (*it2)->removeFromParentAndCleanup(true); bullets.erase(it2); 3.预加载要播放的音乐，初始化时，播放背景音乐，至于显示页面的子弹数和陨石数，只要在移除的时候正确从两个list中移除，读取list其中元素个数即可正确显示。 HitBrick1.打砖块游戏，板子移动和week14同理，主要为关节的固定，首先要给板和球体设置刚体，一个为box一个为circle，并设好弹性系数，摩擦系数，密度。且球为动态刚体，再使用PhysicsJointPin将球固定在板子上，根据PhysicsJointPin的介绍可知其为一个节点使连接的刚体能够自由地围绕其转动，所以将这个节点为两个刚体的锚点的中点，因此在设置时，另一个以板子的锚点为坐标的点应向上偏移到球体的锚点处，即可将Pin固定在球体中心，同时使这个关节内的刚体不能相互碰撞。 joint1 = PhysicsJointPin::construct( player->getPhysicsBody(), ball->getPhysicsBody(), Vec2(0,40), Vec2(0,0)); joint1->setCollisionEnable(false); 2.计算好顶部的长宽和砖块的长宽，循环生成三层的小砖块，并设置物理属性，弹性系数为1，使得完全弹回。并设置碰撞掩码，使砖块相互之间不会触发碰撞事件。 boxbody->setCategoryBitmask(0xFFFF0000); boxbody->setCollisionBitmask(0xFFFFFFFF); boxbody->setContactTestBitmask(0x0000FFFF); 另外顺便给球添加一下粒子效果：设置了一个火焰效果，在球体中心并进行放大。 ParticleFire* fireworks = ParticleFire::create(); fireworks->setPosition(Vec2(250, 250)); fireworks->setScale(3); ball->addChild(fireworks); 3.添加碰撞事件。发生碰撞时调用： if (c1->getBody()->getTag() == 1 || c2->getBody()->getTag() == 1) { GameOver(); } 另外还有一个蓄力操作，当按下SP，通过调度器不断增加速度，当SP松开，将速度赋给球。 spHolded = false; if (joint1 != NULL) { joint1->removeFormWorld(); joint1 = NULL; if (spFactor > visibleSize.height * 1.1) { spFactor = visibleSize.height * 1.1; } ball->getPhysicsBody()->setVelocity(Vect(0, spFactor)); } 四、实验演示Lucia2.0： Lucia初始画面 img[cocos2dx]Lucia初始画面.png 碰撞掉血 img[cocos2dx]碰撞掉血.png 攻击回血 img[cocos2dx]攻击回血.png 死亡画面 img[cocos2dx]死亡画面.png 记录上一次的分数 img[cocos2dx]记录上一次的分数.png Thunder： 主界面 img[cocos2dx]主界面.png Thunder射击 img[cocos2dx]Thunder射击.png Thunder爆炸 img[cocos2dx]Thunder爆炸.png Thunder结束1 img[cocos2dx]Thunder结束1.png Thunder结束2 img[cocos2dx]Thunder结束2.png HitBrick： HitBrick主界面 img[cocos2dx]HitBrick主界面.png HitBrick碰撞 img[cocos2dx]HitBrick碰撞.png HitBrick结束 img[cocos2dx]HitBrick结束.png 更多操作更多操作可能上传到https://space.bilibili.com/33699187/#/中 五、亮点与改进Lucia2.0：建立了一个比较可靠的数据库，能记录最高分，上一次获得的分数（强退时则不会记录），以及本次的分数，并且每次的分数均有保留。一次攻击能攻击多个敌人。 Thunder：当陨石出了边界后，会从列表和画面中移除。当游戏结束后，自动在右下角生成一个重新游戏的按钮，便于重新开始游戏。 HitBrick：1.酷炫的火焰效果。2.合理的难度设计。3.舒适的操作手感。4.不错的游戏反馈。 六、遇到的问题Lucia2.0： 1.怪物工厂判断碰撞时，只会返回其中一个怪物，根据列表顺序来看，是先生成的怪物，所以如果要进行AOE的话，要把该区域的所有怪物都取得，所以在这里我使用了while，直到无怪物返回为止。 2.数据库不知为何cocos2dx库里自带的sqlite3无法使用，只好上网自己下了头文件和编译文件。其数据库操作都很常规。很轻松就能解决。 Thunder： 1.飞船射击游戏雷电，在设计飞船发射子弹时，一开始是让子弹每一段时间进行移动，到边界后逐个移除，经同学提醒后了解到可以使用Sequence + callFuc 的组合，一开始就让子弹飞向边界，到达后自动调用函数进行移除。（使用回调的方法） 2.另外一个比较重要的问题就是子弹撞在陨石后，碰撞事件使用了两层循环遍历，使用erase时，要注意把返回值传递给变量以取得下一个元素（子弹/陨石），且这个时候变量不能自增，因为已经找到了下一个元素。一开始没有这么做导致出现了迭代器为空，以及遍历错误。 3.另外在添加那个重新开始的按钮时，如果先添加后停掉所有事件监听器，这个按钮也是没有用的，这也是为什么我在游戏结束后，再让那个按钮出现的原因，后添加使得按钮能够正常工作。 HitBrick： 1.定义关节一直找不到PhysicsJointPin的定义，后来认真看了介绍应该是相当于二叉树的那种旋转pin，两个刚体围绕着这个节点可以自由旋转，有点像双星系统。因此把板的刚体的点向上偏移到球的那个点，两点重合为一点，这样使得板子围绕球可转（但板子是静态刚体，因此不可转），球自转，达到固定球的效果。 2.摩擦系数过大会导致损失能量，速度会越来越慢，因此我把球的摩擦力调小，其它的也调到极小，这样球就不会旋转，并且依靠摩擦而转向、发生旋转时损失的能量也很小。 3.在设置板的移动时，通过添加速度和改变位置是不一样的，添加速度会使上面的球也有一个速度（惯性），所以发射时会有一个平移的速度，但是直接改变位置就没有这种效果了。 七、思考与总结这三次的作业总的来说还是比较简单的，第一个作业让我了解到了有怪物工厂这种机制，方便进行管理和创建，这样要比把怪物分成很多个更加方便。 之后两个作业更加深入地了解到Cocos2dx这个游戏引擎，当做到与物理引擎相关的作业时，发现有了物理引擎方便很多，再也不用之前那种反物理的移动方式了。。。 另外其物理引擎感觉和其它游戏引擎差不多，都是用刚体这种东西来控制的。游戏用的最多的都是调度器，因为调度器能够时刻监控游戏的碰撞等事件的发生，然后马上作出一些反应出来，Cocos2dx这个物理引擎给我们提供了一个物理环境，使我们的精灵在其中按照设定好的物理属性运作，而相关的事件还是要由我们自己来写。而在处理一些事件时，Sequence + callFuc这种回调方法很有用，相当于异步的效果，使得我们在一些行为的开始后不用去关心如何去结束它。 游戏的难度设定还是挺麻烦的，要给人一种可以玩下去，但又不太简单的样子，有时候加入一些运气成分进去，可以让玩家更加投入到其中，像一些rogue like 游戏，可能这是一种赌徒心态吧。。。。","tags":[{"name":"Cocos2dx","slug":"Cocos2dx","permalink":"http://ziquanzhang.ink/tags/Cocos2dx/"}]},{"title":"[Leetcode] 75.Sort Colors","date":"2018-09-09T02:46:00.000Z","path":"2018/09/09/Leetcode-75-Sort-Colors/","text":"Sort Colors题目链接 题目描述Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with a one-pass algorithm using only constant space? 解题思路这道题主要是对已知数的排序，数组中的每一个数的范围都已确定，因此用以往的排序如快排，归并排序并不合适，要做到一次遍历完成并使用常空间，所以我选择使用插排来完成。 先使用普通的插排发现时间会很慢，而在这个过程中发现一般的插排都是逐个比较的，而这道题目的特殊点在于数的种类较少只有3个，而且是已知的，那么我们可以记录下每个数应插到的位置，就节省了比较的过程。 记录下0，1，2的可插入点的前一位，比如插入1后，1可插点向后移，而2因为只能在1后，所以也向后移，而0不受1影响，插入点不变。最重要的一点是当插入0/1时，会替换掉原本的数，因为后面的数向后移动，可以当作(1，2)/2也插入到数组中（后移替换掉原本的数）。 代码 class Solution { public: void sortColors(vector& nums) { int red = -1, white = -1, blue = -1; for(int i = 0; i < nums.size(); i ++) { if(nums[i] == 0) { red++; white++; blue++; nums[blue] = 2; nums[white] = 1; nums[red] = 0; } else if(nums[i] == 1) { white++; blue++; nums[blue] = 2; nums[white] = 1; } else { blue++; nums[blue] = 2; } } } }; Note值得注意的是我们在写的时候，要把要插入的步骤写在其它数做完后移操作之后，因为存在一种可能假设现在整个数组中还不存在1，当你要插入0时，此时0和1的插入点是相同的，假设你先插入再后移，会使得插入的0被1替换掉（因为我们的后移操作是假设1的插入点前是1，0的插入点前是0），反之1被0替换则正确。 这种算法适合于已知数且不同数较少的排序，用替换取代后移，节省时间和空间。时间复杂度和空间复杂度均为常数。","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ziquanzhang.ink/tags/Algorithms/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://ziquanzhang.ink/tags/Leetcode/"}]},{"title":"I am a title","date":"2018-09-05T07:59:00.000Z","path":"2018/09/05/I-am-a-title-1/","text":"I am the text","tags":[{"name":"test","slug":"test","permalink":"http://ziquanzhang.ink/tags/test/"}]},{"title":"Hello World","date":"2018-09-04T10:58:54.147Z","path":"2018/09/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]